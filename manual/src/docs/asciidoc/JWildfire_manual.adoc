:doctype: book
:sectnums:
:sectnumlevels: 5
:toc:
:toclevels: 3

:title-page-background-image: image::front_cover.jpg[scaledwidth=50%]

= JWildfire users manual
Copyright (C) 2021 by Andreas Maschke

== Introduction
[.thumb]
image::JWildfire.jpg[scaledwidth=75%]

Welcome to JWildfire and this user manual!

The goal of this book is to describe the numerous functions of the software and to explain how they work.
After over 10 years of development there are many functions,
so the book is more a reference book rather than one you might read from start to end.

This book does not attempt to teach you how to create fractals, and it does not include
any practice materials or examples. That would be too much for this manual and will be
part of a kind of "workbook" that I have plans to write.

Anyway, I'm hoping this book will help you to have more fun with the software and achieve
the results you are looking for.

Have fun!

Andreas Maschke, Grambek (Germany) 2021

=== Acknowledgement
Thanks to Brad Stefanov, Nancy Pierce, my wife Patricia Maschke, and Rick Sidwell for their valuable
comments and suggestions for improving this document.

Thanks to the whole fractal art community for their neverending enthusiasm which always pushes me forward.

[#main_editor]

== _Main_ menu
After launching the program the <<fractal_flame_editor, Fractal-Flame Editor>> is opened automatically,
because it is the main module of JWildfire.
There are additional modules and usefull functions which can be reached from with the _Main_ menu.

The _Main_ menu contains the following items:

 - *File*: some file-related functions
 ** *Open flame*: open a flame-file to be edited in the <<fractal_flame_editor, Fractal-Flame Editor>>
 ** *Open image*: open an image-file and display it in a separate window
 ** *Quit JWildfire*: quits the program

 - *Window*: to open/close the various modules of JWildfire (an opened module is indicated by a small checkmark left of the menu item. If it is not visible it might be in background.)
 ** *Fractal flames: Editor*: open the <<fractal_flame_editor, Fractal-Flame Editor>>
 ** *Fractal flames: MutaGen*: open the <<mutagen_module, MutaGen>> module
 ** *Fractal flames: Interactive renderer*: open the <<interactive_renderer_module, Interactive renderer>>
 ** *Fractal flames: Flame browser*: open the <<flame_browser_module, Flame browser>>
 ** *Fractal flames: Easy movie maker*: open the <<easy_movie_maker_module, Easy Movie Maker>>
 ** *Fractal flames: Dancing flames*: open the <<dancing_flames_module, Dancing flames>> module
 ** *Fractal flames: Batch renderer*: open the <<batch_renderer, Batch renderer>>
 ** *Fractal flames: Quilt renderer*: open the <<quilt_renderer, Quilt renderer>>
 ** *Fractal flames: Mesh generator*: open the <<mesh_generator, Mesh generator>>
 ** *Fractal flames: GPU render*: open the <<gpu_rendering, GPU renderer>>
 ** *Fractal flames: Help*: open a popup which displays some helpful informations regarding fractal flame
 ** *IFlames*: open the <<iflames_module, IFlames>> module
 ** *Image processing*: open a popup which offers some image-processing possibilities. Goes back to the old Amiga days.
 ** *Formula explorer*: open a popup which contains a simple function plotter
- *Settings*: options to customize the program
 ** *UI Theme (Look and Feel)*: open a popup to change the UI theme of the whole program
 ** *Preferences*: open the <<preferences, _Preferences_>>-window
 ** *Startup settings (Steam)*: only available in the _Steam version_: opens a window to edit the <<jvm_startup_parameters, Startup options>> for the _Steam Edition_ of JWildfire

 - *Help*: some useful informations and the official documentation
 ** *User manual*: the official user manual (the file you are currently reading)
 ** *System information*: opens a popup to display some usefull information about your system related  to JWildfire, for example, available memory
 ** *Welcome to Jwildfire*: an ancient Welcome-dialog with some useful links, not available in the _Steam Edition_ of JWildfire
 ** *List of changes*: displays the ever-grwowing list of changes. It is a recommended read after each release of the software.
 ** *GPU rendering*: some compact documentation about <<gpu_rendering, GPU-rendering>>
 ** *Supported AI-Post-Denoisers*: some compact documentation about <<ai_based_denoiser, _AI-based denoisers_>>
 ** *Tip of the day*: a small popup which shows small tips at the startup of JWildfire

[#fractal_flame_editor]
== Fractal-Flame Editor
[.thumb]
image::main_editor_with_regions.jpg[scaledwidth=75%]
The Fractal-Flame Editor is the core part of JWildfire.
Here you create random flames or fine-tune your artwork.
It consists of the following parts:

. *Preview/Editor Area*
. *Thumbnail ribbon*
. *Transformations and Scripts*
. *Flame settings*
. *Global functions*

You find a description of each part as separate sub-chapter in this manual.

Most controls have tool tips, short descriptions that appear when you hover
over them for a second.

=== Preview/Editor area
This area is both for previewing fractals and editing them in realtime.
The most simple and intuitive way to edit a fractal is to drag or rotate one of the
visible controls on top of the fractal (usually in the shape of triangles).
However, there are much more precise ways and many other ways to modify a fractal flame.

==== Quick buttons on the top of the preview area
[.thumb]
image::editor_buttons_top.jpg[scaledwidth=50%]

These buttons primarily control the previewing/editing options.

===== _Display/hide variation effect_
Displays the contribution of the currently selected transformation (in the Transformations-area) in the form of a transformed grid.
For example, if the current transformation is a rotation, it will show a rotated grid.
If there are nonlinear transformations (also known as variations or "plugins"),
then the displayed grid may change/deform much more.

===== _Display/hide transparency_
Switch preview-rendering with transparent background on or off.
Please note, that this only affects the preview display and not the transparency setting of the flame itself.

===== _Fine edit_
Turn on or off "fine editing". Fine editing means that changes are less sensitive to changes using mouse or touchpad to allow editing with a higher grade of detail.

[#realtime_preview]
===== _Realtime_
Turns progressive rendering of the preview on or off. Progressive rendering means
that the image starts to render in very low quality and improves with time.
Usually this works well, and allows for fluid editing.
On slower machines (for example, notebooks), this may cause a heavy load, and on some fractals it may cause flickering.
Turning it off will produce a render preview of a lower (non-progressive) quality.

===== _Progress bar_
The progress bar indicates the current render progress in the following cases:

- refreshing the _Preview_ by using the <<render_preview, _Render image preview_>> button
- rendering an image or movie by using <<render_image_movie, _Render image/movie_>> button

===== _Turn grid on/off_
Tuns on or off a grid which may help to align controls. Note that this grid can be moved (see "Edit view of the controls" below), so is intended for control
alignment, not image alignment.

===== _Turn guides on/off_
Turns on or off "artistic guides" for

- *center point*
- *rule of thirds*
- *golden ratio*

which may help to find the right camera position/view.

===== _Style of editor controls_
You may select one of the following styles of editor-controls:

- *axis*
- *crosshair*
- *rectangle*
- *triangle* (default)
- *hidden*

===== _Toggle monochrome/colored controls_
Per default, each control is drawn in its own color to make it more distinguishable.
Sometimes this may distract you from the fractal. Using this option, you may switch
to a less intrusive monochrome display of controls.

[#post_transform]
===== _Toggle post transform_
Quick-switch to toggle between editing of the affine-post-transform and the regular affine transform.

Longer explanation: Transformations are executed in the following order:

. *affine transform*
. *nonlinear transforms*
. *affine post-transform*

In the preview area you may either edit the affine transform or the post-affine-transform
by moving the visual controls with the mouse or touchpad.
This button allows you to switch easily between these two options.

==== Quick buttons on the right of the preview area
[.thumb]
image::editor_buttons_right.jpg[scaledwidth=50%]
These buttons primarily control the type of editing and refreshing the preview.


===== _Enable view editing mode_
In this mode you change the camera settings (view) when dragging the mouse.

- using the mouse-wheel, you may zoom in/out.
- by dragging the mouse with the left mouse-button pressed, you move the camera.
- by dragging the mouse right or left with the right mouse-button pressed, you rotate the camera.

===== _Move triangles mode_
In this mode you edit the affine or post-affine transformation when dragging the mouse.

- using the mouse-wheel, you may scale up/down.
- by dragging the mouse with the left mouse-button pressed, you move the control, causing a translation
- by dragging the mouse right or left with the right mouse-button pressed, you rotate the control, causing a rotation.

===== _Rotate triangles mode_
This mode is similar to _Move triangles mode_, but you are restricted to rotations.
The rotation is done by dragging the mouse right or left while pressing the left mouse-button.

===== _Scale triangles mode_
This mode is similar to _Move triangles mode_, but you are restricted to scale up/down.
This operation is done by dragging the mouse right or left while pressing the left mouse-button.

===== _Enable free point editing_
In this mode you may freely edit the affine transform by dragging the three corner points
of the triangle-controls.
This way you can easily create a free combination of translation, rotation and shear.

===== _Edit view of the controls_
In this mode you edit the appearance of the controls. This doesn't change the flame;
only how the controls look. It can be used to see controls that are outside the window
by moving them or scaling them down. It also controls how sensitive the controls are;
scale them up for finer placement.

- using the mouse-wheel, or by dragging the mouse left or right with the right mouse-button pressed, you may scale them up/down.
- by dragging the mouse with the left mouse-button pressed, you move the controls

See "Turn grid on/off" above.

[#edit_focus_point]
===== _Edit focus point_
Edit the focus-point (parameters FocusX, FocusY and FocusZ at
the <<dof_bokeh_tab, "DOF/Bokeh -> DOF" - tab>>) using the mouse

- by dragging the mouse with the left mouse-button pressed, you change FocusX- and FocusY-parameters
- using the mouse-wheel you change the FocusZ-parameter

===== _Affine XY edit plane_
Sets the current editing-plane for editing affine-transform to the x-y-plane.

The editing of affine-transforms takes place in one plane, the default setting is the x-y-plane.
When editing "classic" 2d-fractals, the x-y-plane is the only plane.
But, when editing 3d-fractals, you may choose different planes, in order to modify all three coordinates.

===== _Affine YZ edit plane_
Sets the current editing-plane for editing affine-transform to the y-z-plane.

===== _Affine ZX edit plane_
Sets the current editing-plane for editing affine-transform to the z-x-plane.

===== _AI Denoiser preview_
Apply the currently selected AI denoiser (OptiX or OIDN) and display it in the preview.
This function uses a split preview, in order to allow you to compare the denoised and the original image.
On the left side, you see the original image, on the right side of the split indicator you
see the denoised image.
This button only appears if an AI denoiser is selected in the <<anti_aliasing_filter_tab, Anti-Aliasing/Filter tab>>.

This function uses the current preview. So it is often recommended to re-render the preview in
higher quality before invoking it.

===== _External render preview_
Open an additional detached progressive preview; works especially well when you are using two monitors.

[#render_preview]
===== _Render image preview_
Re-renders the current preview with a much higher quality level.

This can take some time. The progress bar on the top of the preview area shows the preview progress.
If solid rendering is enabled, there will be a short delay after the progress bar reaches 100%
before the result is displayed.

This is a very important function in the fractal-editing workflow, because certain parameter changes
do not cause a complete re-render of the image, as this would be too slow.
Instead, after such parameter changes, a raw in-memory version of the last preview
to which the parameter change is applied is used.

This is especially helpful when progressive rendering is off (see the _Realtime_ button), where the
preview has very low quality.

So, especially when fine-tuning colors, it is recommended to re-render the preview in higher quality
using this button before changing the settings.
Because this function is of such importance, is has been placed in a prominent place.

==== Quick buttons on the left of the preview area
[.thumb]
image::editor_buttons_left.jpg[scaledwidth=50%]
In this area you find some quick-buttons to reach other modules of JWildfire and the Undo/Redo-buttons.

===== _Interactive renderer_
This is a shortcut for the <<interactive_renderer_module, Interactive Renderer>>.
It opens the <<interactive_renderer_module, Interactive Renderer>> or brings it into the foreground.
It serves no other function, and won't for example, load the current flame into the <<interactive_renderer_module, Interactive Renderer>>.
This was intentional.

===== _Easy Movie Maker_
Opens the <<easy_movie_maker_module, Easy Movie Maker>>.
Automatically adds the currently loaded flame as the first keyframe inside the Easy Movie Maker.

===== _Flame Browser_
Opens the <<flame_browser_module, Flame Browser>>.

===== _Undo_
Reverts the latest change to the currently selected flame.
Each flame has its own undo-history. So undoing a change will not switch between flames.

Please note, that the undo history is not saved together with flames, so it is lost when
you quit JWildfire.

===== _Redo_
Repeats the latest undone change to the currently selected flame.

===== _SShot (Snapshot)_
Create a snapshot of the current flame. This is an identical copy with new undo-history.

===== _Title_
Sets the title of the current flame. This is a good place to also put copyright information
or to add your name (as the author of the artwork).
You can set a default title for flames, which are created using the
<<new_from_scratch, _New from Scratch_>>-button, by setting the
property *tinaDefaultNewFlameTitle* in the <<preferences, _Preferences_>>-window.

===== _3D_
Switch between "classic" rendering and solid rendering.

Solid rendering basically works by treating each sample of the fractal flame as a solid particle.
The sum of all of these particles make up a larger solid shape.
This works only for certain types of flame fractals.
It may fail if the structure is too thin or is in general too "chaotic" or too blurry.
Solid rendering can be used to create really unusual and interesting things.
Here is a render of the "classic" Mandelbulb (thanks to Whittaker Courtney for the idea):

[.thumb]
image::jwf_mandelbulb.jpg[scaledwidth=50%]

===== _Animations controls on/off_
Using this button you may turn on or off animation controls.
You may set up your preference for this setting in the <<preferences, _Preferences_>>-window.

=== _Thumbnail ribbon_
[.thumb]
image::thumbnail_ribbon.jpg[scaledwidth=50%]

The thumbnail ribbon holds thumbnails of all the flames you currently are editing.
After starting the program, some random flames are generated and displayed in the thumbnail ribbon.

You can edit/view any flame of the thumbnail by just double-clicking (or right-clicking) on it.

If you want to return to a previous flame, just double-click the thumbnail of the other flame.
Each flame in the thumbnail-ribbon has its own undo-history.

[#selecting_flames_thumbnail_ribbon]
==== Selecting flames in the _thumbnail ribbon_
Each flame in the _thumbnail ribbon_ has a little checkbox assigned in the upper right corner.
By changing the value of this checkbox you change the selected state of the thumbnail.

Selection of individual flames is only important for saving and deleting.

[.thumb]
image::thumbnail_ribbon_select_menu.jpg[scaledwidth=50%]

By pressing the right mouse-button on top of this checkbox you can open a pop-up menu
to change the selection for all flames inside the _thumbnail ribbon_:

 - *Toggle all*: invert the selection of all flames
 - *Deselect all*: set all flames to deselected state

So, one way to select all flames is to deselect them all and then to invert the selection.

==== Deleting flames in the _thumbnail ribbon_
Each flame in the _thumbnail ribbon_ has also a little delete-button assigned in the upper right corner.
By pressing this button you may delete the corresponding flame from the _thumbnail ribbon_.
Since this can not be undone, a popup will appear to confirm the action.

[.thumb]
image::thumbnail_ribbon_delete_menu.jpg[scaledwidth=50%]

By pressing the right mouse-button on top of this button you can open a pop-up menu
to delete a number of flames from the _thumbnail ribbon_:

- *Remove selected*: delete all flames which are selected (the corresponding checkbox is checked)
from the _thumbnail ribbon_
- *Remove all*: empty the _thumbnail ribbon_

=== Flame settings
At this main tab, you may edit settings at the fractal-flame-level. Most of these settings will
affect the final outcome in a global way, but do not affect the structure of the fractal itself.
For example, you can change the view-settings or the final coloring, but not the shape itself or
which details are computed.

==== _Camera_ tab
[.thumb]
image::camera_tab.jpg[scaledwidth=75%]

With these controls you can control the camera-view. You can rotate and move the camera freely and zoom in/out.

"Classic" flame fractals are flat (2D); they have no depth.
Basically the parameters Roll, CentreX, CentreY and Zoom/Pixels per unit apply to them.
For 3D fractals there are a lot more controls.

But, you can "mix" them, of course. So you can apply all parameters to any fractal and also rotate a 2D flame in space or apply a perspective distortion to it.

===== _Roll_
Camera roll angle in degrees. Rotates around the virtual z-axis and also applies to 2D fractals.

===== _Pitch_
Flame pitch angle in degrees. Rotates the flame around its x-axis.

===== _Yaw_
Flame yaw angle in degrees. Rotates the flame around its z-axis.

===== _Bank_
Flame bank angle in degrees. Rotates the flame around its y-axis.

===== _Perspective_
Camera perspective. A value of 0 indicates no perspective, while higher values produce more dramatic perspective effects. Values can be negative for more interesting effects.

===== _CentreX_
Offset (translation) of the fractal x-direction.

===== _CentreY_
Offset (translation) of the fractal y-direction.

===== _Zoom_
Camera zoom.

===== _Pixels per unit_
Another (classic) measure of zoom. "Pixels per unit" means how many pixels are needed to fill a numerical
distance of 1.0 (in fractal coordinates). The higher the value, the more details (like zooming in).

===== _CamPosX_
Position of the camera in x-direction. Has an effect similar to CentreX for 2D fractals, but a different effect for 3D-fractals.

===== _CamPosY_
Position of the camera in y-direction. Has an effect similar to CentreY for 2D fractals, but a different effect for 3D-fractals.

===== _CamPosZ_
Position of the camera in z-direction.

[#dof_bokeh_tab]
==== _DOF/Bokeh_ tab
DOF (Depth Of Field) is the blurring of parts of the flame based on the distance from the camera.
Whether to use it is very personal. Some people like it a lot (including myself),
some people do not like it at all. So, this sub-chapter describes a rather "special" topic.
Bokeh refers to the shape of out-of-focus points of light in a real camera.
JWildfire can simulate some bokeh effects in conjunction with DOF.

===== _DOF_ subtab
[.thumb]
image::dof_tab.jpg[scaledwidth=75%]

This tab contains some of the more basic settings regarding to DOF.

====== _New DOF_
Switches between classic and more sophisticated (new) DOF modes.
Usually, the "new mode" is recommended. The classic mode is still there because of backwards compatibility.

====== _Amount_
Amount of DOF. A value of zero means no DOF at all.

====== _Area_
Measure of the sharp area around the focus point.

====== _Exponent_
Measure of the falloff of the sharp area around the focus point.

====== _Camera dist_
Only applies to the classic mode and is a measure of the distance of the camera to the focus point.

====== _FocusX_
X-position of the focus point (a point which is sharp). May also be edited interactively in the preview area
(use the <<edit_focus_point, _Edit focus point_>> button).

====== _FocusY_
Y-position of the focus point (a point which is sharp). May also be edited interactively in the preview area
(use the <<edit_focus_point, _Edit focus point_>> button).

====== _FocusZ_
Z-position of the focus point (a point which is sharp). May also be edited interactively in the preview area
(use the <<edit_focus_point, _Edit focus point_>> button).

===== _Bokeh_ subtab
At this tab you can select options to create bokeh-like styles of DOF-effects.
Those options are not available when using solid rendering. For solid rendering there is an option to
apply post-bokeh effects, but those are limited in comparison to the options you find at this tab.

====== _Shape_
Selects the shape of the bokeh-effect

- *Bubble*: the typical and default shape
- *Cannabiscurve*: some nice-looking organic shape
- *Cloverleaf*
- *Flower*
- *Heart*: little hearts, makes nice Valentine-cards
- *NBlur*: has some interesting options to create very different shapes
- *Perlin Noise*: an unusual but interesting style
- *Rect*: very simple but effective style.You can also create "rain"-like scenes with this
- *SineBlur*: a popular circular bokeh
- *StarBlur*: tiny stars
- *Taurus*: another unusual, but interesting shape
- *Snowflake*: a complex snowflake, created wtih the algorithm described in the
paper "A local cellular model for snow crystal growth" by Clifford A. Reiter.
- *SubFlame*: This is the most versatile option: You may use any other fractal as bokeh-style.

====== _Scale_
Global scale of the bokeh-shapes.

====== _Rotate_
Global rotation-angle of the bokeh-shapes.

====== _Fade_
Global falloff of the bokeh-shapes.

====== _Shape specific parameters_
Depending on the bokeh-shape, there are additional parameters.
Most of them are the same as in the variation of the same name. For example, the "Taurus"-bokeh-style has a
parameter N (which is the number of corners). The "taurus"-variation has the same parameter.
Not all parameters of a variation are exposed to the bokeh-style of the same name.

====== Flame (for the Sub-Flame-bokeh-style)
This parameter selects the flame you want to use as bokeh-style.
It is a number, starting with 1. Before you can use a flame as bokeh-style, you must save it to your default
flame-folder by using a filename in the form *"_dof_XXXX.flame"*, where XXXX corresponds to the number
you select here.
For example, when you enter "23" as parameter flame, JWildfire will look for a flame-file with the
filename *_dof_0023.flame*.


===== _Post bokeh_ subtab
[.thumb]
image::dof_post_bokeh_tab.jpg[scaledwidth=75%]
At this tab you can select options to create bokeh-like effects when using solid rendering.
Those options are only available in solid rendering and are limited to the bokeh-related options
which are available for regular flames.

====== _Bokeh intensity_
Overall amount/intensity of bokeh-effects.

====== _Bokeh size_
Size of the bokeh-effects. The larger the effect, the more computation time is required.

====== _Bokeh filter kernel_
Type of bokeh-shape. The default setting produces "classic" flat circular shapes.

====== _Bokeh brightness_
Intensity of the bokeh in comparison the the original image.

====== _Bokeh activation_
Intensity level of the original image for placing bokeh "seeds". The larger the value the more seeds, the more bokeh.

===== _Post blur_ subtab
[.thumb]
image::dof_post_blur_tab.jpg[scaledwidth=75%]

Post-blur is not technically a DOF-effect, but it creates a type of blur, therefore it is located at this tab.
It is not a popular option and primarily resides here for backwards compatibility.

Post-blur works by smudging each rendered sample of the fractal flame.
The effect diminishes with distance to center. It usually makes a fractal appear more bold and "glassy".

====== _Blur radius_
Radius of the blur.

====== _Blur fade_
(Inverse) intensity of the blur. The maximum value means maximum fade out, or no blur effect at all.

====== _Blur falloff_
Strength of diminishing of the effect dependent of the distance to the center of the individual sample.

==== _Coloring_ tab
[.thumb]
image::coloring_tab.jpg[scaledwidth=75%]
At this tab you may edit numerous coloring/tonemapping options to turn your fractals into real artworks.

===== _Brightness_
Overall brightness level of the rendered image. For some fractals even very high values (above 20) may work nicely.

===== _Low brightness_
A tool to increase the brightness of areas with low sampling density. May help to reveal background details
of the fractals which would otherwise be hidden.

===== _Gamma_
Gamma correction level. Small values (below 2.5) increase the brightness of already bright areas and darken
already dark areas, causing some kind of glowing effect.

===== _Gamma threshold_
A density-threshold defining when to apply the gamma correction. In areas with a density below the
threshold a linear transformation is applied, while at areas with higher density the actual gamma
correction is applied. Playing with this value may also help to increase details of areas with low density.

===== _Contrast_
Overall contrast level of the fractal per default maximum contrast. In the most cases it should not be
necessary to alter this value, because lowering the contrast usually leads only to less appealing images.

===== _Red balance_
Overall red balance of the image. A convenient option for fine-tuning the final result without the
need to change the gradient.

===== _Green balance_
Overall green balance of the image. A convenient option for fine-tuning the final result without the
need to change the gradient.

===== _Blue balance_
Overall blue balance of the image. A convenient option for fine-tuning the final result without the
need to change the gradient.

===== _Fade to White_
A measure for the saturation-level of final colors. It can be used to achieve glowing-effects (decrease the value)
or to reduced glowing and make more details visible (increase the value).
Works similar to the gamma-value.

===== _Vibrancy_
Overall vibrancy-level (measurement of the number of different color values). Per default set to the maximum value,
which is very typical for fractal rendering.

===== _Saturation_
Saturation-level of the colors. A convenient option for fine-tuning the final result without the
need to change the gradient.

===== _Bg color_
Background-color which is mixed with the fractal in the foreground to create a smooth looking final result.
There are the following options:

- *Single color*: one single color for the whole background
- *Gradient 2x2*: create a background by blending 4 colors at the corners of a rectangle
- *Gradient 2x2_c*: create a background by blending 4 colors at the corners of a rectangle and one color at the center

===== _Bg image_
Background image which is mixed with the fractal in the foreground to create a smooth looking final result.
Please note, that a background image has higher priority than a background color.
Therefore, if the background image and the background color are chosen, only the background image is rendered.

===== _Fg opacity_
Mixing-level of the foreground (fractal) when applying a background color or background image.
Lower values make the foreground less transparent, but may increase antialiasing effects.

===== _Background transparency_
Turns rendering with transparent background (alpha channel) on or off. This option is usually used when you
want to use your fractal images inside other software packages like Adobe Photoshop to compose a final
artwork out of different images or parts.
Please note, that you may also activate a preview of the background-transparency in
JWildfire (in the top area of the preview-window).

[#anti_aliasing_filter_tab]
==== _Anti-Aliasing/Filter_ tab
[.thumb]
image::antialiasing_tab.jpg[scaledwidth=75%]
At this tab you find some very important settings which help to improve the visual quality or "cleanliness"
of your fractal artworks.
For details about filtering see the sub-section <<how_filtering_works, _Filter kernel preview/How filtering works_>>.

===== _Spatial oversampling_
Factor of spatial oversampling. Spatial oversampling works by internally rendering an image of larger size
and then creating a final of (usually) better quality by taking all this additional information into account.

 - a value of 1 means no spatial oversampling
 - a value of 2 means rendering internally an image of double size (double the width and double the height,
so it requires about 4 times of the memory)
- a value of 3 means rendering internally an image of triple size (triple the width and triple the height,
so it requires about 9 times of the memory)

The recommended value is 2.

Please note that, while higher levels of spatial oversampling require much more memory, they do not need much
higher rendering time.

===== _Filtering_
Global filtering strategy for building the final image by taking into account the fractal iteration information:

 - *Global sharpening*: creates an image with consistent high sharpness
 - *Global smoothing*: creates an image with consistent high smoothness
 - *Adaptive*: tries to sharpen details, while smoothing "unsharp" areas as well as areas with low density

===== _Filter kernel_
Select the filter kernel to apply. There are different choices, depending on the selected _Filtering_ option.

The following values are recommended (but feel free to play with other settings as well):

 - *Global sharpening*: *Mitchell-Filter*
 - *Global smoothing*: *Sinepow10*
 - *Adaptive*: *Mitchel_Sinepow* (*Mitchel*-Filter for sharpening details, *Sinepow10*-Filter for smoothing areas of low density)

[#how_filtering_works]
===== _Filter kernel preview/How filtering works_
Creating a fractal image is an elaborate process consisting of several steps.
Filtering is one of these steps and very important for the final outcome.
It takes place after the iteration-process which creates a lot of individual "measure points" of the fractal,
called samples.

One pixel of the final image is usually calculated considering several raw pixels that are in close proximity
to the source pixel. Here, a kind of averaging of all pixel values around the middle pixel takes place,
which ultimately leads to an improved quality of the final image (than if only one raw pixel per final
pixel would be considered).

The filter-kernel-preview in the middle of the _Anti-Aliasing/Filter_ - tab shows a visual representation of
this behavior. Higher bars correspond to a higher influence of a sample, while lower bars correspond to a lower
influence.
Usually, the highest influence is in the center, which makes sense because the sample at the position
of the final pixel usually should have an important influence.

====== _Example: Gaussian-filter_
[.thumb]
image::filter_preview_gaussian.jpg[scaledwidth=75%]
The Gaussian-filter is a very popular filter for smoothing. You can understand this behavior in
the preview:

 - the middle sample has the largest influence.
 - samples which have a certain distance to  the center, have a smaller influence.
 - this influence is smaller the more far the sample is.

====== _Example: Mitchell-filter_
[.thumb]
image::filter_preview_mitchell.jpg[scaledwidth=75%]
The Mitchell-filter is a very popular filter for sharpening.
In comparison to a smoothing filter, it has small areas with negative contributions, which
cause the sharpening effect.

====== _Example: Box-filter_
[.thumb]
image::filter_preview_box.jpg[scaledwidth=75%]

The box-filter is a special filter because it creates averages from a number of samples.
You can see this clearly in the preview, having only bars of the same size, i.e. each sample has the
same contribution.

===== _Filter radius_
A numerical value indicating the size of the effective filter kernel around each sample.
A value of 0 means no filter kernel at all, higher values lead to a growing of the filter kernel, you
can see this very well in the filter-kernel-preview.

Useful values are in the range of 0.5 ... 1.5, depending on the filter kernel and amount of spatial oversampling.

===== _Sharpness indicator_
This value helps the Adaptive filter to decide which portions of the image should be sharpened and
which should be smoothed.

The higher the value, the more areas are treated as smooth areas.
The lower the value, the more areas are sharpened.

This is a very abstract value, but there is a preview-mode which helps to visualize the different areas.
This feature is described in the sub-section <<adaptive_filter_preview, _Adaptive filter preview_>> .

===== _Low density_
This value helps the Adaptive filter to decide which portions of the image should be treated as areas
with low density, and which areas should be smoothed regardless of density.

Usually, smoothing in areas of low density is more intense than in regular smoothing areas,
therefore the distinction.

The higher the value, the more areas are treated as low density areas.
The lower the value, the more areas are treated a general smoothing areas.

This is a very abstract value, but there is a preview-mode which helps to visualize the different areas.
This feature is described in the sub-section <<adaptive_filter_preview, _Adaptive filter preview_>>.

===== _Flat preview_
Displays a flat preview of the filter-kernel. In this type of view negative values (which are typical for sharpening filters)
are indicated red.

[#adaptive_filter_preview]
===== _Adaptive filter preview_
[.thumb]
image::filtering_show_indicator.jpg[scaledwidth=75%]
By enabling the small checkbox labelled "Indicator" and re-rendering the preview (Click the Render image preview button
on the right of the preview area.) you get a visualization of the different areas detected by the _Adaptive filter_ .

 - *red*: sharp areas
 - *green*: smooth areas
 - *blue*: areas with low density (which are also smoothed)

[.thumb]
image::preview_sharpness_indicator.jpg[scaledwidth=75%]

===== _Antialiasing amount_
Antialiasing is a technique to defend hard (or "jagged") lines or isolated pixels which seem too important.
It works by adding a little "chaos" to the individual samples.
The _Antialiasing amount_ is a measure of this "chaos".
The higher the value, the more "chaos" is applied, causing less hard lines, but possibly also causing fewer
details.
Set to 0 to disable antialiasing.
See also _Antialiasing radius_ for another parameter to influence antialiasing.

===== _Antialiasing radius_
Radius of the added "chaos" to avoid jagged lines. See _Antialiasing amount_ for a more detailed
description.

[#ai_based_denoiser]
===== _AI-based denoiser_
Type of AI-based denoiser applied to the final image:filtering_show_indicator.jpg

 - *OptiX*: a very popular denoiser by NVIDIA, requires a modern graphics card from NVIDIA, see https://developer.nvidia.com/optix-denoiser
 - *OIDN*: an open-source-denoiser by Intel, comes with fewer requirements than OptiX, see https://www.openimagedenoise.org/
 - *None*: no post-denoiser

While not mandatory for rendering single images, these AI-based denoisers are extremely
helpful when it comes to render animations. By using an AI-based denoiser you can cut down
rendering times significantly, by factors of 10 or more.

This works by choosing a very low render quality in JWildfire (for example, lower than normal by factor 10)
and then "completing" those usually noisy images by using the AI-based denoiser.
It is amazing how well this works.
When you then finally assemble a compressed video sequence, you usually can see no difference when compared to rendering all the frames in high quality.

Please note, that AI-based denoisers are not available on all platforms. Therefore, JWildfire performs
some self-test at startup and presents only the available options.

You can preview this feature using the _AI Denoiser preview_ - button in the preview area.

===== _OptiX filter blend_
This option is only available when choosing the OptiX denoiser. See _AI-based denoiser_ fr details.
It defines a blend between the original (noisy) image and the denoised image.

 - a value of 0 means that the original image is not blended with the denoised image at all, showing only the denoised image
 - a value of 0.5 would mean that there will be created an average of the original and the denoised image.

Usually, small values in the range 0 .. 0.2 are recommended.

You can preview this feature using the _AI Denoiser preview_ - button in the preview area.

===== _Denoise image_
Using this button you can denoise an external image using the currently selected AI-based denoiser.
When using the OptiX-denoiser, also the parameter _OptiX filter blend_ is respected.

This feature is useful when you want to play with different denoising-settings or forgot to enable
the denoiser or just want to denoise some non-Jwildfire-image.

Please note: It is recommended to use PNG as file-format, others may work as well, but are not
guaranteed to work. So, eventually you have to convert the image before denoising it.

==== _Gradient_ tab
At the gradient tab you find numerous option to create and modify the gradients of your fractals.
Notice: gradients are sometimes also referred as "palette" or "color palette".

===== _General controls_ subtab
[.thumb]
image::gradient_tab_general_controls.jpg[scaledwidth=75%]
The gradient-tab contains both some general controls and some sub-tabs.The former are described in this
sub-chapter.

====== _Edit gradient_ button
Opens/closes the classic gradient-editor of JWildfire. It is outdated and not described here.
This gradient editor was superseeded by the curve-editor you find at the _Curve editor_ subtab.

====== _Random_ button
Shortcut for creating a new random gradient (using the current settings at the _Create new_ subtab).
Gradient changes are also part of the undo-history of the fractal flame, so you may switch through
the randomly generated gradients by Undoing/redoing afterwards.

====== _Save_ button
Save the current gradient to the gradient-library (as *.map-file).
See the sub-chapter _Gradient library_ for futher details.

====== _Rnd grd_ button
Select a random gradient from your gradients-library. Per default, the built-in library is selected.
If you want to choose a random gradient from your own gradient-library or a sub-folder inside it, you
must select the right folder first.

====== _Shift_
Modifies the gradient-shift, which moves all colors by the given amount.
This is non-destructive operation. Colors, which are "moving out" at one end of the gradient
are "moving in" on the other side.

====== _Rnd shift_ button
Applies a randomly chosen _Shift_ value

====== _Rnd clr_ button
Sets the _Color_-parameter of all transformations of the fractal to a random value.

This does not change the gradient, but does change how it is applied to generate the
final coloring of the fractal.

====== _Rnd spd_ button
Sets the _Speed_-parameter of all transformations of the fractal to a random value.

This does not change the gradient, but does change how it is applied to generate the
final coloring of the fractal.

====== _Reset clr_ button
Sets both the _Color_- and the _Speed_-parameter of all transformations of the fractal to zero.

This does not change the gradient, but does change how it is applied to generate the
final coloring of the fractal.

====== _Distribute clr_ button
Distributes the _Color_-parameter of all transformations of the fractal evenly.

This does not change the gradient, but does change how it is applied to generate the
final coloring of the fractal.

===== _Gradient library_ subtab
[.thumb]
image::gradient_library_tab.jpg[scaledwidth=75%]

At this tab you can select pre-saved gradients and apply them to your fractal by just clicking
at them.
The gradient-library contains of two parts:

- in-built gradients: those are installed together with the program and can not be modified in any way
- your own gradients. They are located in a folder outside the JWildfire-installation-drawer,
  so that they are not lost when you update JWildfire. You must specify this path in the
  <<preferences, _Preferences_>> by setting the property *tinaGradientPath*.

User-defined gradients may be structurized in sub-folders in order to make them more easily accessible.

===== _Create new_ subtab
[.thumb]
image::gradient_create_tab.jpg[scaledwidth=75%]

At this tab you can create gradients by various options.
The most common use is to create random-gradients by selecting one of the sophisticated built-in
random-gradient-generators.

====== _Random gradient_ button
Create a new random gradient using the currently selected options, which are described in the following sub-sections.
Each new gradient is a separate entry in the undo-history of the currently selected flame fractal, so you can
cycle through all the generated gradients by using the _Undo_ and _Redo_ button.

====== _Gradient generator_
You may choose on of the following gradient generators:

 - *(All)*: meta-random-gradient-generator which randomly chooses a random-gradient-generator to create the gradient
 - *Strong hue*: creates a smooth  gradient with strong colors
 - *Stripes*: creates a gradient with many regular color changes, having a "stripy" look
 - *Monochrome*: creates a smooth and monochrome radient
 - *Smooth*: creates a smooth gradient with primarily pastel colors
 - *Bold*: creates a non-smooth gradient with large blocks of strong colors
 - *Two colors*: creates a smooth gradient by fading exactly two colors into each other
 - *Uniform curves*: creates a random color curve with evenly distributed base colors and then
 derives the gradient from it. Using this generator you have both a gradient and
matching color curves.
 - *Uneven curves*: creates a random color curve with unevenly distributed base colors.
Using this generator you have both a gradient and matching color curves.
This setting creates usually the most interesting and versatile gradient together with the
corresponding color curves and is the default.

====== _Random points_
Number of random base colors to derive a gradient from. The more base colors, the more different
colors do you have in the final gradient.

Please note, that this setting is not respected by all
random-gradient-generators (e. g. _Two colors_ will always only use two colors).

====== _Fade colors_
Fade the base colors in order to create a smooth gradient, which is the default setting.

Please note, that this setting is not respected by all
random-gradient-generators (e. g. _Bold_ will never fade colors).

====== _Uniform widths_
Distribute the base colors over the size of gradient in an uniform way.

====== _Base colors_ table
In this table you can manually edit the base colors after a gradient was created.

Please note, that those base colors are not saved. So you can only edit them
at the time you create gradients, but not after saving and loading a flame.

====== _Create similar gradient_ button
Creates another random gradient which has similar colors to the current gradient,
but has a different distribution over the area of gradient.

====== _Extract from flame_ button
Load a gradient from a flame-file.

====== _Create from image_ button
Imports an image and creates a gradient from the most frequent colors found in that image.

===== _Curve editor_ subtab
[.thumb]
image::gradient_curve_editor_tab.jpg[scaledwidth=75%]

Color curves are an alternative way to edit gradients.
Using color curves usually gives much more control over the final result because it allows
a very interactive editing of both the gradient and the flame at the same time.
Additionally, it allows more direct control over modifying the colors of a gradient,
making it much easier to create "dramatic" effects.

Internally, each gradient consist both of the "classic" part of the gradient and three
curves: *hue*, *saturation* and *luminosity*.
Those curves belong to the flames, and are also stored within the flame-files.

When loading an older flame-file without those curves, or assigning a "classic" gradient
to a flame, the color curves are approximated.
Usually, this  is only a very raw approximation, but this is absolutely intended.
To reach a very accurate approximation, it would require to have a lot of curve-points,
which would make the curve very hard to edit.
Therefore, the goal of the raw approximation is to make the actual editing easier.

So, there is no exact synchronisation between gradient and colors curves,
in order to not break existing flames and concepts.
Instead, it is meant as a powerful additional tool, which is useful in very many cases,
but might not be useful in every case.

Only when you start to edit one of the curves, the gradient is synchronized to the shape of the curves.
When you save and re-load a flame you can continue the editing of the curves.

Each curve has a toolbar with little buttons to help with editing:

  - open a modal dialog for editing an enlarged version of a particular curve
  - create ramp-shaped curve
  - create line-shaped curve at the bottom (constant zero intensity)
  - create line-shaped curve at the middle (constant half intensity)
  - mirror the curve at the vertical axis
  - mirror the curve at the horizontal axis (for example, to turn a constant line of zero intensity
into a line with maximum intensity)

===== _Modify gradient_ subtab
[.thumb]
image::gradient_modify_tab.jpg[scaledwidth=75%]
At this tab you can modify the gradient globally.
Please note, that this does not respect color-curves, so they will be out of sync, if any.

===== _Swap RGB_
Swaps the color channels which changes the finally colors dramatically.
Different values swap different channels.

===== _Frequency_
Repeats the gradient inside itself. The higher the frequency the more copies are made.
Because the copies must fit in the place of one gradient, they are scaled down.

===== _Blur_
Blur smudges the colors of the gradient making it more smooth or "unsharp"

===== _Invert_
Turns the colors of the gradient into negative colors.

===== _Reverse_
Mirrors the positions of the colors (last color will be first and vice versa).

===== _Sort_
Sorts the colors by hue and brightness.

===== _Apply all current modifications_ button
All of the above options are "non-destructive" which mean they do not actually modify the gradient,
but are applied dynamically. Using the _Apply all current modifications_ button you can
finalize those changes by actually applying them to the gradient.

===== _Balancing_ subtab
[.thumb]
image::gradient_balancing_tab.jpg[scaledwidth=75%]
At this tab you can modify the colors of the gradient by applying typical color balancing operations.
Please note, that this does not respect color-curves, so they will be out of sync, if any.

===== _Red_
Change the red color balance.

===== _Green_
Change the green color balance.

===== _Blue_
Change the blue color balance.

===== _Hue_
Increase or decrease the hues of the colors of the gradient.

===== _Saturation_
Increase or decrease the saturations of the colors of the gradient.

===== _Contrast_
Increase or decrease the contrasts of the colors of the gradient.

===== _Gamma_
Apply an overall gamma correction.

===== _Brightness_
Change the overall brightness.

===== _Apply all current balancing-options_ button
All of the above options are "non-destructive" which mean they do not actually modify the gradient,
but are applied dynamically. Using the _Apply all current balancing-options_ button you can
finalize those changes by actually applying them to the gradient.

===== _Color map_ subtab
[.thumb]
image::gradient_colormap_tab.jpg[scaledwidth=75%]
At this tab you find a very experimental feature which lets you use an image as gradient.
It works well only for flat fractals.
When coloring the fractal it takes into account both the position at the (x,y)-plane and the local
color information from the iteration process.

===== _Select image_
Select an external image.

===== _H Offset_
Horizontal offset of the image map.

===== _H Scale_
Horizontal sizing of the image map.

===== _Local Add_
Measure of influence of local color information at the current position.

===== _Local Scl_
Measure of another type of influence of local color information at the current position.

===== _V Offset_
Vertical offset of the image map.

===== _V Scale_
Vertical sizing of the image map.

===== _Remove image_
Remove the selected color map (and revert to use a regular gradient for coloring).

[#solid_rendering]
==== _3D rendering_ tab
At this tab you can influence the outcome of a fractal rendered in solid mode.
This is also an experimental feature of JWildfire.

Solid rendering basically works by treating each sample of the fractal flame
as a solid particle.
The sum of all of these particles make up a larger solid shape.
This works only good for a certain types of flame fractals and needs more rendering time
than "classic" fractal flames.

Solid flames usually don't work well if the structure is too thin or is in general too "chaotic" or too blurry.

Solid rendering can be used to create really unusual and interesting things.

===== _Ambient shadows_ subtab
[.thumb]
image::3drendering_ambient_shadows_tab.jpg[scaledwidth=75%]
Ambient shadow calculation is an effective method for approximating more complex physical processes
that cause it to be darker in small corner ends or crevices.

There are several methods to implements this, JWildfire uses a method based on
"Image-Space Horizon-Based Ambient Occlusion", which was developed by NVIDIA.

Ambient shadows are a global effect which is independent from any light sources.

====== _Enable ambient shadows_ checkbox
Enable or disable Ambient shadow calculation (also known as ambient occlusion).

Please note that ambient shadows are applied after the main iteration process, so it will not be displayed
in realtime during progressive rendering. Click the Render image preview button to preview the result.

====== _Amb shadow intensity_
Intensity of the ambient shadows. The higher the value the higher the darker the shadows in small corners.
If changed after a preview render, the results are seen immediately in the preview.
(This is not true of the other ambient shadow settings.)

====== _Search radius_
Distance to search for ambient occlusions.
Affects both the quality and the overall appearance of the ambient shadows.
Optimum values depends on the individual fractal. The default value should work not too bad in most cases, though.

====== _Blur radius_
Blur amount of ambient shadows. A value of 0 means no blur at all, which would look very unnatural.

====== _Falloff_
Falling off of the shadows. Higher values lead to higher falling off, making the shadows smaller.

====== _Radius samples_
Number of samples in radius-search-direction. Higher values increase both quality of the shadows
and rendering time.

====== _Azimuth samples_
Number of samples in azimuth-search-direction. Higher values increase both quality of the shadows
and rendering time.

====== _Affect diffuse_
An experimental option to let influence the diffuse lighting by ambient shadows.
This is in no way physically correct, but can help to generate more dramatic effects.

===== _Hard shadows_ subtab
[.thumb]
image::3drendering_hard_shadows_tab.jpg[scaledwidth=75%]
At this tab you can configure classic hard shadows which are geneated with the help of shadow maps.

Hard and ambient shadows can be used at the same time and work well together.

====== _Shadow type_
There are the following options:

 - *Off*: don't calculate hard shadows. This is the default setting
 - *Fast*: classic hard shadows
 - *Smooth*: a modification of hard shadows which smoothes them at the edges.
Produces artifacts in some cases. You should use then *Fast* shadows.

====== _Smooth radius_
Radius for smoothing hard shadows.

====== _Shadowmap size_
Resolution of the shadow map. The higher the resolution, the higher the quality of
the shadows, but the higher the memory consumption.

Please note, that a shadow map is required for each lightsource. So, having many light sources
may increase memory consumption indirectly, when using shadow maps.

====== _Shadowmap bias_
Sometimes shadow maps produces little stripy artifacts. By setting a small bias value those artifacts
can be bypassed. The bias value must not necessarily high when there are a large number of artifacts.

===== _Material settings_ subtab
[.thumb]
image::3drendering_material_tab.jpg[scaledwidth=75%]
Here you can set up the materials of your fractal.
Fractals can have any number of materials, which are selected by
a material-index similar to colors by the color-index.

====== _Selected Material_ drop-down list
Here you select the material you want to edit.

====== _Add_ button
Create a new material.

====== _Del_ button
Delete the currently selected material. Use with caution as this will renumber the remaining materials but not references to them.

====== _Diffuse_
Amount of diffuse reflection which is light reflected from rough surface.
The color of this component is determined by the colors of the light sources.

====== _Ambient_
Amount of ambient light. The color of this component is determined by the fractal color.

====== _Specular_
Amount of specular reflection which is light reflected from a smooth surface.
The color of this component is determined by the _specular color_.

====== _Spec size_
Size of the specular reflections. Higher values produce smaller and more intense reflections.

====== _Diffuse response_
Controls how the material reflects diffuse light.

====== _Specular color_
Color of specular reflections.

====== _Reflection map_
Allows mapping an image as environment which is reflected on the object surface.

====== _Refl mapping_
The function used to map the image to the environment.

====== _Refl intensity_
Amount of light emitted by the reflection map.

===== _Light settings_ subtab
[.thumb]
image::3drendering_light_settings_tab.jpg[scaledwidth=75%]
At this subtab you may set up directional light sources for solid rendering.

You may have as many light sources as you want.

====== _Selected Light_ drop-down list
Select the light source you want to edit.

====== _Add_ button
Add a light source.

====== _Del_ button
Remove the currently selected lightsource.

====== _Altitude_
Changes the light direction by altering the angle between the light and the z-axis.

====== _Azimuth_
Changes the light direction by altering the angle between the light and the yz-plane.

====== _Light color_
Color of this light, used in the calculating the diffuse component of reflection.

====== _Cast shadows_
Choose if this light should cast shadows or not. Affects only hard shadows.

====== _Light intensity_
Intensity of the lightsource.

====== _Shadow intensity_
Intensity of the shadow casted by this lightsource.

===== _ZBuffer_ subtab
[.thumb]
image::3drendering_zbuffer_tab.jpg[scaledwidth=75%]
When rendering in solid mode, you may also export an additional z-buffer-image.
The settings on this tab help to customize the creation of this z-buffer.

Hint: To export an z-buffer you must activate the option _with Z-Buffer_ in the _Quality_-profile, you are using.
See the sub-section about <<quality_profiles, _Quality Profiles_>> for more details.

====== _ZBuffer scale_
Affects the amplitude of the z-shift/depth-effect caused the z-buffer.
The higher the value, the more dramatic the depth-effect caused by this z-buffer.
If positive, close areas are light and far areas are dark. If negative, close areas are dark and far areas are light.

====== _ZBuffer bias_
Moves the minimal z-shift.

====== _ZBuffer filename_
There are two options to control how the filename of the z-buffer-image is determined:

 - *zbuf_name*: use image filename prefixed with "zbuf_"
 - *name_depth*: append "_depth" to the image filename

==== _Stereo3D_ tab
At this tab you can change options for rendering Stereo3D images.
There are many options here, including settings to generate classic anaglyph images
as well as options to generate interpolated images.

===== Stereo3d mode
Sets the type of Stereo3D mode:

 - *None*: no Stereo3D rendering
 - *Anaglyph*: the classic way to generate a Stereo3D image: creates one image for each eye,
turns them into gray, turns the gray into two different monochrome tones, and compose
those two images together.
Creates one image per frame.
Requires special 3d glasses with the matching colors to view the image.
 - *Side by Side*: creates one image for each eye and put them side by side.
Creates one image per frame.
 - *Interpolated images*: create a number N of interpolated images for each eye.
Creates 2 * N images per frame.

===== View angle
Angle between the eye-lines, also called Stereo angle.

===== Eye distance
Distance between the eyes.

===== Focal offset
Offset off the camera in z-direction.

===== Preview mode
Type of preview for Stereo3D-effect:

 - *None*: no Stereo3D-preview. The fractal flame is displayed like a regular fractal flame.
 - *Anaglyph*: preview as anaglyph image
 - *Side by Side*: preview in side-by-side mode
 - *Side by Side Full*: preview in enlarged side-by-side mode

*Please note, that the preview currently does not work correctly in Realtime mode.
When creating Stereo3d-images, it is recommended to <<realtime_preview, turn Realtime mode off>>*

===== Left eye color
Color of the left-eye-image in anaglyph mode. There are the following options:

 - Red
 - Cyan

===== Right eye color
Color of the left-eye-image in anaglyph mode. There are the same options as for the left eye.

===== Images per eye
Number of interpolated images which are created for each eye in _Interpolated Images_ mode.

===== Swap sides
When checked, swaps the images for the left eye with the image for the right eye.
Side-by-side stereo images are normally designed for parallel viewing.
Checking this box creates stereo images for cross-eyed viewing.
For some people is easier to see the 3D-effect this way, while for others is easier the
other way.

==== _Post symmetry_ tab
The options at the _Post symmetry_ tab are a very easy way to add symmetry to your fractal flames.
You could also achieve this by adding certain transformation to your fractal, but this would require
much more editing effort.
Because symmetry is a very commonly used feature in fractal imagery, JWildfire offers this additional way
to easily play with it.

==== Symmetry type
There are the following symmetry types:

- *None*: no symmetry
- *X-axis*: mirror-symmetry along the x-axis (the mirror is the y-axis).
Often used to create angel-like fractals.
- *Y-axis*: mirror-symmetry along the y-axis (the mirror is the x-axis)
Often used to portal-like fractals.
- *Point*: point-symmetry (often used in the process)
Often used to create Mandala-like fractals.

==== Distance (only for X-axis- and Y-axis-symmetry)
Measure of the distance between the object and the mirror

==== Rotation (only for X-axis- and Y-axis-symmetry)
Rotation angle of the mirror.

==== Symmetry order (only for Point-symmetry)
Order of the symmetry. Can be thought as the number of copies which are placed around the
symmetry center.

==== CentreX
Offset in the x-direction to place the symmetry-center.

==== CentreY
Offset in the y-direction to place the symmetry-center.

==== _FPS/Motion blur_ tab
At this tab you can adjust options for motion-blur as well as the Frames Per Second setting for animations.
While motion-blur is typical for animations (hence the name), it can also be used to create
interesting effects for still images.

[#motion_blur_length]
===== Blur length
Number of time steps to create for each frame. The more time steps, to smoother the effect, and the
more calculation time is requiered.

Recommended values are in the range of 16 ... 48.

A value of 0 means no motion blur.

*Please note, that the calculation of motion blur may significantly reduce the realtime-animation-playback-speed.*
If you notice performance problems when previewing animation, you should turn motion blur temporarily off.

[#motion_blur_time_step]
===== Time step
The time difference for each computed blur step. Larger time steps produce a larger blur length, but produce
also visual gaps between the individual steps.

===== Decay
Fall-off of the brightness of the generated time-steps. The visual difference increases with each time-step, which
produces "trails" with diminishing intensity at the ends.

[#fps]
===== FPS
Number of generated frames per second. This setting is a general setting for animations and is not tied to
motion-blur.

==== _Layers_ tab
Layers allow you to create complex flames by composition of other fractals.
Unlike using traditional layers in image processing software, the layers in JWildfire are still
fractals which are "alive" and can be modified as you know it from regular flames.
So you can edit each layer before rendering the final image.
Additionally, layers respect that flames have three coordinates, so each layer can be moved freely in
space before rendering the image.

Flames are by nature translucent, so are always superimposed over each other.
There are no "blend modes" and the order of layers doesn't matter.

Each layer has its own:

 - set of transforms
 - set of final transforms
 - gradient

All other settings (camera, coloring, post symmetry, etc.) affect the whole flame, i.e. all layers at a whole.

===== Basic manipulations
There are basic functions for manipulating layers:

 - *Add*: to create a new blank layer with a new randomly created gradient
 - *Duplicate*: to create a new layer and copy all transforms, final transforms and the gradient
from the currently selected layer
 - *Delete*: to delete the currently selected layer, please note, that the last layer cannot be
deleted
 - *Extract*: will create a new flame in the thumbnail using only the layer that is currently selected

===== Layer properties
Layers have the following properties which you can modify:

 - *Caption*: a free text you can use to describe the layer
 - *Visible*: this property controls if the currently selected layer is rendered or not
 - *Weight*: this property controls the intensity/weight of the current layer.
1 is normal, lower values darkens the layer, higher values make it lighter.
 - *Density*: this property controls the density of the layer: 1 for full density to 0 for no density.

===== Hiding/Showing layers
It may be important to show/hide certain layers to help focus your editing. There
are two useful functions to support this workflow:
 - *Hide all others*: Hides all layers except the currently selected one.
 - *Show all*: makes all layers visible

=====  Enabling _Layer append_mode
If you activate the button _Layer append mode_ on the layers-tab, every fractal you load into the
editor, will be appended as layer. If the fractal to append has more than one layer, all layers are appended.
Only the transforms, final transforms, and gradient are appended. The other settings are ignored.

===== Adjusting flame position and orientation inside a layer
You can move any fractal (layer) freely like a 3D-object in a 3D-modeling-software. All you need is a
final transform. In flames which already have a final transform just enable _Post transform_-editing-mode
and you are able to drag, rotate and scale the fractal by using the mouse.

If you work with 3D-fractals you may also want to modify the fractal along the z-axis. This is also
easily done using the final transform, but you have to add variations which perform the desired
transforms as:
 - *post_rotate_x* and *post_rotate_y*
 - *post_ztranslate_wf*
 - *post_zscale_wf* etc.

===== Layer indicators
There are two indicators to help you to work with layers:

 - A red text "layer-append-mode active" on top of your preview if the append-mode is on.
 - A small realtime-preview of the currently selected layer on top of the main preview. This
preview is only visible if you have more than one layer and more than one layer is visible.
So if you hide all layers except one (for fine-tuning of this layer) the small preview is hidden
and does not distract you. You can also turn off the preview by deactivating the Layer preview
button on the left of the Layers tab.

==== _Channel mixer_ tab
Using the channel-mixer you may influence the final coloring of your fractal by color-curves.
This modifies the final colors by mapping input values to arbitrary output values.

The simplest case is to take into account brightness levels.
The default curve is a linear ramp. Each brightness value outputs the same value.
But, when you start to modify the brightness curve, you may change this behavior.
For example, drag the curve to higher values at lower levels and vice versa.
This will increase the brightness of dark areas and darken brighter areas.

You can do the same with color levels. Overall, there are the following options:

 - *Off*: no color curves
 - *Brightness*: one curve which affects only the brightness levels:
 **  new brightness as function of old brightness
 - *RGB*: one curve for each color channel:
 ** new red as function of old red
 ** new green as function of old green
 ** new blue as function of old blue
 - *Full*: three curves for each color-channel:
 ** new red as function of old red, old green and old blue
 ** new green as function of old red, old green and old blue
 ** new blue as function of old red, old green and old blue

==== _Quick mutations_ tab
"Quick mutations"-tab allow easily creating a batch of variations of the currently selected flame.
You may load any of those mutations into the main editor by double-clicking at it.
This creates a new flame in a new slot and does not alter the original flame in any way.
You may set the default batch size for quick mutations in the <<preferences, _Preferences_>> (property *tinaQuickMutationBatchSize*).
You may also set the default mutation-type for quick mutations in the <<preferences, _Preferences_>> (property *tinaQuickMutationDefaultMutationType*).

[#quick_mutation_types]
===== _Mutation type_ drop-down list
Here you can choose the type of mutation to be executed:

 - *Add transform*: add a random transformation
 - *Add variation*: add a random variation to a randomly selected transformation
 - *Affine*: randomly change parameters of the affine part of a randomly selected transform
 - *Affine3D*: randomly change parameters of the affine part in all three dimensions of a randomly selected transform
 - *Bokeh*: add a randomized bokeh-effect
 - *Change weight*: randomly change the weight of randomly selected transformations
 - *Color type*: randomly change the color-type of randomly selected  transformations
 - *Gradient position*: randomly change the color-parameter of randomly selected  transformations
 - *Local gamma*: add randomized local-gamma-effects
 - *Random gradient*: create a new random gradient
 - *Random parameter*: change some randomly selected parameters of randomly selected variations
 - *Random ztransform*: randomly change parameters of the affine part primarily affection the z-axis of a randomly selected transform
 - *Similar gradient*: create a similar gradient
 - *Weighting field*: add randomized weighting-field-effects
 - *All*: randomly select one of the above mutations. This is the default option.

 - *User1*, *User2*, *User3*: user-defined lists of mutations. You may customize them in the <<preferences, _Preferences_>> by
editing the properties *tinaMutaGenMutationTypesUser1*, *tinaMutaGenMutationTypesUser2* and *tinaMutaGenMutationTypesUser3*

==== _Batch size_
Here you can specify the number of create quick mutations.
In some cases in may make sense to use a large number. So you can create a huge batch of quick mutations with
one click and then view them later.

=== _Transformations and Scripts_
_Transformations_ and _scripts_ are the creative heart of JWildfire. Using _transformations_ you
actually create and modify the fractal structure of a fractal flame, and using _scripts_ you
can automate this.

==== _Transformations_
At this tab you can modify the structure or shape of the fractal itself.
You do this by adding and modifying transformations.

===== _Theory_
It is beyond the scope of this book to explain exactly how transformations work and fractal flames
are generated in general.
If you are interested in the math behind fractal flames, a very good ressource
is the dissertation of Scott Draves, the inventor of the fractal flame
itself: https://flam3.com/flame_draves.pdf

But, many of the actions described here are very intuitive to use, and allow you to
create fractal artworks without knowing the exact backgrounds (which are not too intuitive from
an artists view.)

Besides this users manual I'm planning to write another book which brings those two worlds (theory and practice) together.
But, at the time of writing this, this will take some time.

===== _Transformations_ table
This table displays all transforms of the currently selected fractal flame.
There are two types of transform:

- (regular) *Transforms*: they build the actual structure of the fractal
- *Final transforms*: they are applied after the regular transforms and do only affect the shape
after it is created, but not the inner details.

You may think of them both as *transforms* being the *polygonal mesh* in a classic 3D-software, and
*final transforms* being deformations of this mesh.

===== Transformation _weights_
Each transform has a numerical weight-value attached. This value influences the priority
of this transform in the iteration process of the fractal.

===== Transformation _order_
Please note, that there is _no_ transformation order. Swapping the positions of two transforms
would not change the fractal, hence there are no buttons to change the positions of the
transformation inside the table.

Importance/influence of a transform can be affected by:

- the *weight* of the transform itself
- *relative weights*, also known as *Xaos*-values

===== _Add_ button
Adds a new transform.

===== _L (Linked transform)_ button
Adds a linked transform. A linked transform is a regular transform which has a special setup
of _relative_ weights, so that it is executed after the transform it is linked to, hence the name.

===== _T (Rename transform)_ button
Opens a popup to enter a name which is displayed in the transformations table. Useful for complex fractals.

===== _Dupl_ button
Duplicate the currently selected transform.

===== _Delete_ button
Delete the currently selected transform.

===== _Add final_ button
Add a final transform. You can add multiple final transforms.
*Please note, that all final transforms are applied at each iteration step. Therefore
final transforms massively affect render performance.* This does not hold for regular transforms.

===== _Affine_ tab
At this tab you can modify the affine part of a transform. This is very intuitive because
an affine transformation is a possible combination of

- movement
- rotation
- scale
- shear
- reflection

Affine transformations are represented by the controls you see in the preview
area. So, at the _affine_ tab you can perform the same changes like dragging controls in the
preview, but in a more precise way.

===== _Post TF_ button
Switches between editing the regular part of a transform the <<post_transform, Post-transform>>-part.

===== _Reset TF_ button
Resets the selected part (regular or post) of the current transform.
This means setting the transformation coefficients so that there is no movement, rotation and scale.

==== _Preserve Z_ button
Adds a linear transform in z-direction. This is a very special feature which is helpful in creating
3d-fractal flames which should contain nonlinear-transforms which only support x- and y-axis
and would make the fractal flat.

==== _X1_, _X2_, _Y1_, _Y2_, _O1_, _O2_ fields
These are called affine transformation coefficients, and build the actual value of the transform.
Sometimes they also called *c00*, *c01*, *c10*, *c11*, *c20*, *c21* or *a*, *b*, *c*, *d*, *e*, *f*.
If the YZ or ZX edit plane is selected, Z1 and Z2 will replace one of the other pairs.

There are two sets of this cooeficients, one set for the regular part and one set for the post part.

===== _Nonlinear_ tab
???

===== _Xaos_ tab
???

===== _Color_ tab
???

===== _Gamma_ tab
???

===== _WField_ tab

==== _Scripts and Custom-Buttons_
At this tab you can manage JWF-scripts and organize custom buttons which allow easier access
certain scripts.

Custom-buttons are completely optional. You can also execute scripts directly from the _Scripts_ library
by double-clicking at a script.

JWF-scripts are written in the Java-language and can use most of language-features offered by
Java 1.4. So you could also read external files, access ressources from the internet,
open custom-windows etc.
There are also several possibilities to interact with the <<main_editor, Main Editor>>,
for example, to modify the currently edited flame and to refresh the preview.

===== _Scripts_ libary
The scripts-library contains of two parts:
- built-in scripts: those are installed together with the program and can not be modified in any way
- your own scripts. They are located in a folder outside the JWildfire-installation-drawer,
so that they are not lost when you update JWildfire. You must specify this path in the
<<preferences, _Preferences_>> by setting the property *tinaJWFScriptPath*.

User-defined scripts may be structured in sub-folders in order to make them easier accessible.

===== _Import script_ button
Import a script from an external file. The following file-types are supported:

- a single *.java*-file containing the script-code
- a *.zip*-archieve containing the script-toger together with additional files or folders.

When you download scripts from the internet, for example, from https://www.jwfsanctuary.club, they usually come
as .zip-file.

===== _New_ button
Create a new script from scratch. This is rarely used, it is often more useful to duplicate
an existing script or to create a script form a flame and then to modify it.

===== _Dupl_ button
Duplicates the currently selected script.

===== _From flame_ button
This is a very useful function to get started with creating scripts. It creates a script
which contains all the Java-code to create the currently selected flame.

This has the following purposes:
- you have a working script which actually produces something with a single button-click
- by modiyfing certain parts you can programmatically create similar flames

===== Creating flame-randomizers
This function also creates code, which randomizes certain parameters at the level
of each transform. This code is inactive by default.
So, the generated flames by this script will alsways look the same until you
modify the script. This is intended, because randomizing a random selection of
parameters usually does not lead to interesting results. So you must find out by yourself,
which parameters are good fro randomizing a flame and which are not. This always depends
on the type of fractal and small differences between flames may affect this behavior in
a very strong way.

You can find the inactive code by looking for comments like this:
[source,java]
----
// random affine transforms (uncomment to play around)
//   XFormTransformService.scale(xForm, 1.25-Math.random()*0.5, true, true, false);
//   XFormTransformService.rotate(xForm, 360.0*Math.random(), false);
//   XFormTransformService.localTranslate(xForm, 1.0-2.0*Math.random(), 1.0-2.0*Math.random(), false);
// random affine post transforms (uncomment to play around)
//   XFormTransformService.scale(xForm, 1.25-Math.random()*0.5, true, true, true);
//   XFormTransformService.rotate(xForm, 360.0*Math.random(), true);
//   XFormTransformService.localTranslate(xForm, 1.0-2.0*Math.random(), 1.0-2.0*Math.random(), true);
----
The first line is an actual comment (not code). But the 2nd line is code, which was commented out.

- _Commenting in_ means to remove the characters *//* at the start of line, this activates the code.
- _Commenting out_ means to add the characters *//* at the start of a line, this inactivates the code.

If you now _comment in_ the 3rd line, you apply a rotation by an angle which is randomized.
[source,java]
----
XFormTransformService.rotate(xForm, 360.0*Math.random(), false);
----
The expression *360.0*Math.random()* calculates a random value in the range of 0..360, which
differs each time you execute the script. So you will get a different fractal flame
each time you execute the script.

When you see, that this leads to interesting effects, you may leave it that way and work at another transformation,
otherwise you could uncomment another line of this pre-generated code. You can also play with the values, for example,
to replace the *360* by some smaller value when the rotations are too large.
Of course, you can combine all of this code-fragments freely and also add your won code.
But, a rule of thumb is, that many large changes at a fractal flame at the same time
do not lead to interesting results. In many cases you will not have any visible result at all.

===== _Btn_ button
Create a <<macro_buttons, _Macro button_>> in the bottom area of the preview to execute the currently selected script.
You can remove this button using the _Delete_-button at the <<macro_buttons, _Macro buttons_ subtab>>.

===== _Scan_ button
Rescans the script-library. This is only necessary when you modified files outside from JWildfire or changed
the library-path in the _Preferences_.

===== _Run_ button
Runs the currently selected script.

===== _Edit_ button
Opens a popup-window to edit the currently selected script.

===== _Description_
You can enter a description of your script as plain text. Here you can give hints for usage or place copyright information.

===== _Code preview_
Shows the code of the script. Because this area is too small for making changes there is a separate _Edit_ button
to edit the script.

[#macro_buttons]
===== _Macro buttons_
At this tab you can create and modify so-called _Macro buttons_. A _Macro button_ is a button which executes a
script. Scripts are also called _Macros_, hence the name.

====== _Macro buttons_ table
In this table all _Macro Buttons_ are displayed and you can also edit the label and shorthint of each button.

====== _Up_ button
Moves the selected entry on position up. The corresponding button will move one position to the left.

====== _Down_ button
Moves the selected entry on position down. The corresponding button will move one position to the right.

====== _Delete_ button
Deletes the currently selected _Macro button_.

=== Global functions
At this area you find global functions as well as the very often used ones.

==== _Random batch_ button
Create a new batch of random flames and displays it in the _thumbnail ribbon_.
This is probably one of the most popular features of JWildfire, because using this function
you can create endless beauty in a very relaxing way. It is also very unlikely that you will
ever generate two fractals which look exactly the same, so it possible that you
are surprised by new and interesting results even after years of use of the program.


Please note, that this will per default remove any previously loaded flames together
with their undo-history from memory. So, any change you did not save yet, will be lost.
You can change this behavior by editing the parameter *tinaRandomBatchRefreshType* in
the <<preferences, _Preferences_>>.

The random-flame-generating-process can be influenced by changing the following parameters:

 - *Rnd flame-generator*
 - *Rnd Symmetry*
 - *Rnd Gradient*
 - *Rnd WField*
 - *tinaRandomBatchSize* (in the <<preferences, _Preferences_>>)
 - *tinaRandomBatchBGColorRed*, *tinaRandomBatchBGColorGreen*, *tinaRandomBatchBGColorBlue* (also in the <<preferences, _Preferences_>>)

All of these parameters may be combined freely to create customized random flames. See the following sub-sections
for more details about these parameters.

===== Example of combination of parameters for creating specific random flames

For example, to generate mandala-like-structures which look very organic and have a yellowish background, you could
use the following setup:

 - *Rnd flame-generator*: *Simple (stunning)*
 - *Rnd Symmetry*: *Point*
 - *Rnd Gradient*: any
 - *Rnd WField*: *(All)*
 - *tinaRandomBatchBGColorRed*: *235*
 - *tinaRandomBatchBGColorGreen*: *215*
 - *tinaRandomBatchBGColorBlue*: *75*

[.thumb]
image::rnd_flame_gen_mandala.jpg[scaledwidth=75%]

==== _Rnd flame-generator_

Choose here the random-flame-generator used to generate a batch of random flames.
A random-flame-generator is a set of instructions to generate a skeleton of a certain type of fractal
and fill this skeleton with random values or random sub-structures.
What works good and what works not, depends on the type of fractals. Sometimes it just the
random change of some single number, sometimes a random transformation or formula is inserted.

Usually, the random-flame-generators of JWildfire use the strategy, to use some well-explained
ranges of parameters together with some larger freedom. This way you get very often a pleasing result,
but maybe also new variations, which you never saw before (or which may never been tried before at all).

There are two types of random-flame-generators:

 - *meta-random-flame-generator*: uses randomly-chosen random-flame-generators internally
 - *random-flame-generator*: actually creates a random flame

===== The special "All"-random-flame-generator
The most common random-flame-generator is the default generator named "All".
It is a meta-random-flame-generator and contains all other random-flame-generators.
When it generates a random flame, it selects randomly one of those internal generators
to do the actual work.
So, by choosing "(All)" you will get the most diverse results.

==== Rnd Symmetry
Sets the random-symmetry-generator used for generating random flames.
A random-symmetry randomly sets post-symmetry-options of the random flames.

There are the following options:

 - *None*: the flame will have no post-symmetry
 - *XAxis*: a random x-axis-symmetry
 - *YAxis*: a random y-axis-symmetry
 - *Point*: a random point-axis-symmetry
 - *(All)*: randomly selects a random-symmetry-generator to generate post-symmetry
 - *(All, sparse)*: like *(All)*, but with reduced probability to generate post-symmetry at all

The default value is *(All, sparse)*, which means to randomly create random symmetry of all types,
but only a few random flames.

See the section about _Post symmetry_ for more details about the types of post-symmetry and related parameters.

==== Rnd Gradient
Set the random-gradient-generator used for generating random flames.

There are the following options:

- *(All)*: meta-random-gradient-generator which randomly chooses a random-gradient-generator to create the gradient
- *Strong hue*: creates a smooth  gradient with strong colors
- *Stripes*: creates a gradient with many regular color changes, having a "stripy" look
- *Monochrome*: creates a smooth and monochrome radient
- *Smooth*: creates a smooth gradient with primarily pastel colors
- *Bold*: creates a non-smooth gradient with large blocks of strong colors
- *Two colors*: creates a smooth gradient by fading exactly two colors into each other
- *Uniform curves*: creates a random color curve with evenly distributed base colors and then
derives the gradient from it. Using this generator you have both a gradient and
matching color curves.
- *Uneven curves*: creates a random color curve with unevenly distributed base colors.
Using this generator you have both a gradient and matching color curves.

The default setting is _Uneven curves_, which creates usually the most interesting and
versatile gradients together with the corresponding color curves.

==== Rnd WField
Set the random-weighting-field-generator used for generating random flames.

There are the following options:

 - *Cellular Noise*: create random weighting-fields using Cellular Noise
 - *Basic Noise*: create random weighting-fields using basic noise, like Perlin noise
 - *Fractal Noise*: create random weighting-fields using fractal noise, like Perlin fractal noise.
Fractal noise means to apply one type of noise multiple times at different scales.
 - *Image Map*: create random weighting-fields using an image map.
Per default always the same fixed internal map is used. You can exchange it by editing the flame afterwards.
 - *(All)*: randomly selects a random-weighting-field-generator to generate weighting-fields
 - *(All, sparse)*: like *(All)*, but with reduced probability to generate weighting-fields at all

[#new_from_scratch]
==== New from scratch
Create a new and empty flame with a random gradient. This is usually the first step when creating a fractal
manually "from scratch", hence the name.

==== From clipboard
Load a flame which was stored in the clipboard.

In social-media it is common to exchange flame-files in text-form by posting them. When loading such a flame
you usually copy the text and the use the _From clipboard_ button to load into JWildfire.

==== Load flame
Load a flame from a file and display it in the _Thumbnail ribbon_.

Flame files can also contain a batch of flames. In this case each flame from the flame-batch-file will be
imported as individual flame, which is displayed as individual thumbnail in the _Thumbnail ribbon_.
Each individual flame  of such a batch also has its own undo-history.

==== To clipboard
Stores the currently selected flame in text-form in the Clipboard.

In social-media it is common to exchange flame-files in text-form by posting them.
Using this function you may export your flame to paste it somewhere, for example, at Facebook.

==== Save flame
Save the currently selected flame.

==== Q (Quicksave)
Quicksaves the currently selected flame by automatically generating a filename in the
form *"qsave_" + <Date> + <Counter> +".flame"* in the folder where the last flame was saved (the default flame folder if this is the first).
You may set the default flame folder in the <<preferences, _Preferences_>> by changing the property *tinaFlamePath* .

==== A (Save all)
Save all selected flames together into one flame. Selected flames are indicated by a small checkmark at the
right upper edge of the thumbnail. See the sub-section <<selecting_flames_thumbnail_ribbon, _Selecting flames in the thumbnail ribbon_>>
for more information about selecting flames.

[#render_image_movie]
==== _Render image/movie_ button
Render the current flame using the selected <<quality_profiles, _quality_>> and <<resolution_profiles, _resolution profile_>>.

Rendering means to create a final image and consists of the following steps:

 - perform the fractal iteration process, possibly using internal a larger resolution than the desired image resolution.
See _Spatial oversampling_ for details.
 - perform tone-mapping by turning the raw fractal information into colored pixels.
See the section about the _Coloring tab_ for more details.
 - optionally perform AI-based denoising. See _AI-based denoiser_ for more details.

When you click the Render image/movie button, you will be prompted for the filename to use.
The extension determines whether to render an image or movie. Use .png or .jpg to render an image, or .mp4 to render a movie.

The rendering runs in the background and can be cancelled at anytime. But, you can not render
more than one flame at a time at this place. For rendering multiple images see the section
about <<batch_renderer, _Batch renderer_>>.

==== _Render resolution_ drop-down list
Here you choose the desired render resolution by choosing a _Resolution profile_.
JWildfire comes with some predefined _resolution profiles_, but you can completely customize them.

Even when you do not render the flame in the main editor, the correct render resolution should be
specified because of the aspect ratio. After changing a _resolution profile_, JWildfire will change the
size of the preview-area accordingly to the aspect ratio of the selected _resolution profile_.
For example, when you select a profile with same width and height, you will have a preview-area
of square shape.

[#resolution_profiles]
==== Edit _resolution profiles_
Edit the list of resolution profiles by clicking the button to the right of the render resolution drop down list.
In this popup-window you may alter existing _resolution profiles_ as well as creating your own.

There are the following parameters:

 - *Width* x *Height*: image resolution
 - *Default profile*: one profile can be defined as the default profile. The profile is chosen when you start JWildfire.

==== _Render quality_ drop-down list
Here you choose the desired render quality as well as some output options by choosing a _Quality profile_.
JWildfire comes with some predefined _quality profiles_, but you can completely customize them.

Especially, when using a AI-based post-denoiser, you may want to revisit your quality profiles.
Such a denoiser can help to create visual appealing results with much lower quality settings
in order to reduce render time. The default settings are thought to be used without such an denoiser.
See the sub-chapter _AI-based denoiser_ for more details.

_Quality profiles_ also contain the information which type of images should be generated.
For example, you may specify inside a _quality profile_ that JWildfire shall generate an additional z-buffer-image
when using solid rendering.

[#quality_profiles]
==== Edit _quality profiles_
Edit the list of quality profiles by clicking the button to the right of the render quality drop down list.
In this popup-window you may alter existing _quality profiles_ as well as creating your own.

There are the following parameters:

- *Quality*: quality level
- *with HDR*: create an additional _High Dynamic Range Image_ in .hdr-format.
Such an image contains raw colors in a much more precise way than conventional images.
But, it can usually not be displayed without special software.
Is is similar to an RAW-image in photography.
- *with Z-Buffer*: create an additional z-buffer-image. Together with the actual image of the fractal you can
create "3d wiggle images" which are/where popular on some social media platforms like Facebook.
Currently, this is only implemented for fractals rendered in solid mode.
- *Default profile*: one profile can be defined as the default profile. The profile is chosen when you start JWildfire.

==== Batch renderer
Quick-saves the currently selected fractal flame and sends it to the <<batch_renderer, _Batch renderer_>>.

Please note, that this does not actually render the fractal flame.
You must later open the _Batch renderer_ and invoke the rendering process.
So, it is just a shortcut to simplify adding fractal flames to the rendering batch.

Hint: when you continue to  edit the fractal flame and create a quicksave again, the _Batch renderer_
will still render the quicksave you did sent to the _Batch renderer_ before.

[#mutagen_module]
== _MutaGen_ module
[.thumb]
image::MutaGen.jpg[scaledwidth=75%]

In this module you may create mutations of a certain flame in an interactive way.
Open the MutaGen module by selecting _Fractal flames: MutaGen_ from the _Windows_ menu.

There are several mutation types affecting different "genes" (types of flame properties).
Those mutations are applied at two levels: generation A (8 new fractals from the base flame)
and generation B (16 new fractals from generation A), generating total 24 new flames at each mutation step.

You can easily exchange fractals between the main editor and the new module at any time.

There is also a history, i.e. you can navigate back to earlier generations at any time.

See the section about <<quick_mutation_types, _Quick mutation types_>> for a description of available mutation types.

[#interactive_renderer_module]
== _Interactive Renderer_ module
[.thumb]
image::interactive_renderer.jpg[scaledwidth=75%]

The _Interactive Renderer_ is an alternative rendering module which focuses on rendering a single image
(In contrast, the <<batch_renderer, _Batch Renderer_>> focuses on rendering multiple images).
Open the Interactive Renderer module by clicking the Interactive Renderer button on the left of the preview area or
by selecting _Fractal flames: Interactive renderer_ from the _Windows_ menu.

_Interactive Renderer_ has three main purposes:

 - watch the rendering process for important artworks and let it render "until it is done"
 - explore random fractal flames and watch them get rendered clear and clearer. This may be very relaxing
 - explore the fractal rendering process in general

=== Saving the image while rendering
While rendering is in progress you may save a snapshot of the current image at any time.
This will not influence or even interrupt the ongoing rendering process in any way and is
an intended workflow.

=== Stats
Statistics about the current quality level and predictions when new quality levels will be reached
are shown in the top left of the Interactive Renderer window.

You may toggle viewing of Stats of when you are not interested in them by clicking the Stats button.
This will improve render performance only slightly, though.

=== Preview
While previewing the image during rendering is a key-feature of the _Interactive Renderer_, it also
slows down rendering. For most of the flames the slowdown can be neglected, but there can be
a significant slowdown for some flames.
So you may want to alternate between faster rendering for a short period and monitoring the
render progress using the Preview button.

=== From Editor
Imports the currently edited fractal flame from the _Main Editor_ and start rendering it.

*Please beware, that this will cancel any ongoing render and you will lose any unsaved results.*

=== From Clipboard
Imports a fractal flame from the clipboard and start rendering it.

*Please beware, that this will cancel any ongoing rendering and you will lose any unsaved results.*

=== Load flame
Loads a fractal flame from a flame start rendering it.

*Please beware, that this will cancel any ongoing rendering and you will lose any unsaved results.*

=== Resume render
Load a previously saved <<render_state, _Render State_>> and start rendering it.

*Please beware, that this will cancel any ongoing rendering and you will lose any unsaved results.*

=== Stop
Stops the currently ongoing rendering process.

*Please beware, that the render can not be resumed. You must save the <<render_state, _Render State_>>
before stopping the render when you want to be able to continue a render.*

=== 1:2
Sets the render size to the half of the currently selected render size. Can help to get a quick preview
when rendering at huge resolutions.

=== 1:4
Sets the render size to the quarter of the currently selected render size. Can help to get a quick preview
when rendering at huge resolutions.

=== Full
Use the full render resolution of the selected <<resolution_profiles, _Resolution Profile_>>.
This is the default setting.

=== Resolution
Desired render resolution. See the sub-section about <<resolution_profiles, _Resolution Profiles_>>
for defining custom resolutions.

[#render_state]
=== Save render state
Save the current state in a proprietary format. You may load this file later to continue rendering
at exactly the same step.

=== Save image
Create a snapshot of the current render and save it as image.

=== Z (Save Z-Buffer)
Create a snapshot of the current render and save it as z-buffer. Currently z-buffers are only
supported when rendering in <<solid_rendering, solid mode>>.

=== Autoload saved image
When this option is checked, JWildfire will automatically load and display images created by
_Save image_- and the _Z (Save Z-Buffer)_-function.
To view the actual final image may help help better to decide when "it's done" that to view the rendering-preview.

=== To Editor
Transfer the currently rendered flame to the Main editor.

=== To Clipboard
Transfer the currently rendered flame to the clipboard.

=== Save Flame
Save the currently rendered flame to file.

=== Next (random flame)
Creates a random flame and starts rendering it.

*Please beware, that this will cancel any ongoing rendering and you will lose any unsaved results.*

=== Random generator
Select the random-flame-generator used to generate a random-fractal-flame when using the _Next_-button.

[#flame_browser_module]
== Flame Browser
[.thumb]
image::flame_browser.jpg[scaledwidth=75%]

The flame-browser can help you to get an overview over your fractal flames you create over the time.
It can scan a base-folder for flame-files and displays them as thumbnails in reverse chronologinal order.
For a cleaner structure, for each month a separate virtual folder is created and flames are distributed over
this folder-structure.
Open the Flame Browser by clicking the Flame Browser button on the left side of the preview area or by
choosing _Fractal flames: Flame browser_ from the _Windows_ menu.

On the right side of the window you can execute one of the following actions on the selected flame:

 - *To Editor*: load the selected flame into the <<main_editor, _Main Editor_>>
 - *To Batch Renderer*: send the selected flame into the <<batch_renderer, _Batch renderer_>>
 - *To Mesh Gen*: send the selected flame into the <<mesh_generator, _Mesh generator_>>
 - *Delete*: delete the selected flame
 - *Rename...*: rename the selected flame
 - *Copy to...*: copy the selected flame into another folder
 - *Move to...*: move the selected flame into another folder

[#easy_movie_maker_module]
== _Easy Movie Maker_ module
[.thumb]
image::easy_movie_maker.jpg[scaledwidth=75%]
With the _Easy Movie Maker_ you can create animations consisting of multiple flames.
Open the Easy Movie Maker module by clicking the Easy Movie Maker button on the left of the preview area or
by selecting _Flame fractals: Easy movie maker_ from the _Windows_ menu.

It combines three types of animation:

 - the keyframe-based animation of a fractal flame itself. You set up those kind of animations in the
<<main_editor, Main Editor>>
 - transitions between two fractal flames
 - global animation scripts, for example, a movement of the camera

You can even generate random movies, which is an experimental feature.

=== _Thumbnail ribbon_
Similar to the <<main_editor, Main Editor>> there is a thumbnail ribbon on the left, which hold all
currently loaded objects - in this case: movies. You may select a movie by double-clicking at its thumbnail.

=== Function at the main button bar (at the top)
Here you find global functions at the movie level.

==== _Random movies_
Using this button you can generate random movies using the selected random-movie-generator.
This works by generating random-flames and then applying random motions to it.
This is currently limited to create movies containing only one animated flame.

===== _Rnd generator_
There are the following options:

 - *Transforming bubbles*: generates a random fractal of type _bubbles_ and applies random motions at transformation-level to it
 - *Transforming duckies*: generates a random fractal of type _duckies_ and applies random motions at transformation-level to it
 - *Rotating Mandelbrots*: generates a random fractal of type _Mandelbrot_ and applies a random rotation-motion to it
- *All*: randomly selects one of the random-movie-generators mentioned above to generate a random movie

==== _From clipboard_
Loads a movie-file from the clipboard and appends it to the _thumbnail ribbon_.

==== _From movie_
Loads a movie from a file and appends it to the _thumbnail ribbon_.

==== _To clipboard_
Transfers the currently selected movie in text-form to the Clipboard.

==== _Save Movie_
Saves the currently selected movie to a file.

==== _Resolution_
Here you select the <<resolution_profiles, _resolution profile_>> for rendering the movie.

==== _Quality_
Here you select the <<quality_profiles, _quality profile_>> for rendering the movie.

==== _Output_
There are the following output-options for generating a movie:

- *Flames*: Produces a batch of flame-files (one flame file for each frame position), which are rendered later
using the <<batch_renderer, Batch renderer>>. This is the recommended setting for larger projects, because
using the <<batch_renderer, Batch renderer>> for rendering images is the most comfortable way in JWildfire.
It supports pausing/resuming and limited <<gpu_rendering, GPU-rendering>>.
- *PNG-Images*: Produces a batch of .png-images by taking into account the selected resolution- and quality-settings.
You need some external software (like _VirtualDub_) to actually create a video-file from this batch of images.
Recommended for simple projects, which can be completely rendered in up two hours.
- *MP4*: Directly produces an .mp4-movie by also taking into account the selected resolution- and quality-settings.
This is recommended for very simple projects or quick test-renders, because there are no options to fine-tune the video-compression-settings (yet).
- *ANB*: Produces an _Animated Brush_ in *.anb-format, which is used by painting software _Project Dogwaffle Howler_.
Because the output is a brush you use for painting, it is only recommended for small animations.
Takes also the selected resolution- and quality-settings into account.

=== The timeline
At the bottom there is a timeline where you can place individual flames.
Each animated fractal flame has the following attributes:

 - *Duration (frames)*: number of frames the flame is part of the whole movie
 - *Morph (frames)*: number of frames of the transition to the next flame. This sub-frames are part of the
whole duration. For example, when you have a duration of 120 frames, and a transition of 60 frames, the transition
will start at frame 61
 - *Morph type*: type of transition. There are the following options:

 ** *Fade*: fades the first flame out and the second flame in. Works for any flames
 ** *Morphs*: tries to actually morpth between the flames at the transformation level.
Does only work well for flames which do not differ too much. But often produces interesting
results, even if they were not as expected.

There are the following actions you can perform at animated flame level:

 - *_E_* (Edit): transfers the current flame to the <<main_editor, Main Editor>>
 - *_R_* (Replace): replaces the current flame with the currently loaded flame of the <<main_editor, Main Editor>>.
In combination with the _E_ button this allows easy post-editing of a flame.
 - *_D_* (Delete): Remove the current flame from the movie

==== _Add from Editor_ button
Appends the currently loaded flame of the <<main_editor, Main Editor>> to the movie.

==== _Add from Clipboard_ button
Appends a flame from the Clipboard to the movie.

==== _Add flame from disc_ button
Load a flame from a file and appends it to the movie.

==== _Up_ button
Moves the currently selected animated flame one position up (to the left). The currently selected flame is
indicated by a filled radio box right of the _D_ button.

==== _Down_ button
Moves the currently selected animated flame one position down (to the right). The currently selected flame is
indicated by a filled radio box right of the _D_ button.

==== _Remove flame_ button
Removes the currently selected animated flame from the movie. The currently selected flame is
indicated by a filled radio box right of the _D_ button.

==== _Remove all_ button
Removes all flames from the movie.

=== _Global (animation) scripts_
Lets you apply up to 12 global animations scripts to the whole movie, i.e. those scripts are applied to
each individual flame in the form of a post-effect. They override motions of the same type, in case
they were are already applied at the flame-level.

There are the following options (which may be combined freely):

- *None*: no motion applied to the slot
- *Rotate Roll/Pitch/Yaw/Bank*: constant rotation of the camera, by modifying the _Roll_- or _Pitch_- or _Yaw_-
or _Bank_-parameter of the flame
- *Move CamX/CamY/CamZ*: a movement of the camera into the x-, y- or z-direction in the form a sine-wave (moving gently back and forth)

By changing the numerical value right of each script slot you may change the strength of the effect.

=== _XForm (animation) scripts_
Lets you apply up to 12 flame transformations to the whole movie, i.e. those scripts are applied to
each individual flame in the form of a post-effect. They override motions of the same type, in case
they were are already applied at the flame-level.

There are the following options (which may be combined freely):

- *None*: no motion applied to the slot
- *Rotate Full*: constant rotation of all affine-transform
- *Rotate First/2nd/3rd/4th/Last XForm*:  constant rotation of the specified affine-transform
- *Rotate Final XForm*:  constant rotation of the final-affine-transform
- *Rotate Post Full*: constant rotation of all post-affine-transform
- *Rotate Post First/2nd/3rd/4th/Last XForm*:  constant rotation of the specified post-affine-transformat
- *Rotate Post Final XForm*:  constant rotation of the post-final-affine-transform

Those animations are only applied when a flame has the corresponding transformations.
For example, selecting the animation script _Rotate Final XForm_ on a flame without a final
transform will have no effect, but will also not cause an error

By changing the numerical value right of each script slot you may change the strength of the effect.

=== (animation)Speed/Motion blur
Here you can specify the overall animation speed (_frames per second_) and set up motion blur
for the whole movie.

==== Total frame count
Displays the total frame count which is calculated accordingly to the inividual settings of the
animated flames.

==== Frames per second
Global <<fps, fps-setting>> of the movie.

==== Motion blur length
Global <<motion_blur_length, motion blur length>> of the whole movie.

==== Motion blur timestep
Global <<motion_blur_time_step, Motion blur timestep>> of the whole movie.

=== Preview
You can preview the animation at any time by hitting the _Play_ button in the middle of the window.

==== _Frame_
Display the frame position at which the preview is displayed.

==== _E_ (Edit) button
Sends the currently displayed flame (at the selected frame position) to the editor.
This might especially interesting when you are morphing between different
flames and like the result at a certain frame position and want to work with
the fractal flame at the current morphing-state.

[#dancing_flames_module]
== _Dancing flames_ module
[.thumb]
image::dancing_flames.jpg[scaledwidth=75%]

The dancing-flames-module is another experimental feature of JWildfire.
Open the Dancing flames module by selecting _Fractal flames: Dancing flames_ from the _Windows_ menu.

It allows you to create sound-synchronized animations of fractal flames in a very
sophisticated way.

What can you do:

 -  animate anything! (i.e., any property of a flame which can be accessed in the flame-editor
can be animated)
 - synchronize motion with sound (a frequency spectrum computed by a Fast Fourier Transform (FFT),
a computer algorithm commonly used to analyze sounds, can be used to link motion with "beat")
 - create motion curves (amplitude over time) for certain properties by using a spline editor or
apply a predefined motion (basing on a certain formula, like "Sawtooth")
 - group motions together (for example, have a spline-motion-curve which is slightly altered by beat")
 - watch the motion in realtime and record it to be processed again to create frames at
accurate framerate
 - use any number of fractal flames in your movie and switch between in realtime during the recording
step
 - load and save projects

=== The basic concepts
The basic concept of the animations in the dancing-flame-module is both very versatile and very simple
and contains of four building blocks:

 - motions
 - flame properties and
 - motion links
 - motion hierarchies

==== Motions
You can define any number of motions, for example:

- a rotation with frequency x
- "beat" data of a certain channel from the FFT
- a manually created motion curve using the spline-editor
[.thumb]
image::dancing_flames_add_motion.jpg[scaledwidth=30%]

Each motion has special parameters which can be accessed through a property table. There are
some parameters which can found by all motion-types.
[.thumb]
image::dancing_flames_motions.jpg[scaledwidth=50%]

==== Flame properties
Each flame has a lot of properties. Most of them can be easily be animated, for example:
 - camera angle
 - zoom factor of transform 2
 - Julia index of variation "julian" in the final transform
You have not to know all of those, they can all be accessed through a tree-view in the graphical
interface.
[.thumb]
image::dancing_flames_properties.jpg[scaledwidth=50%]

Each fractal flame has its own top-level-folder in this view. There are sub-folders for:
 - each transform
 - each final transform
 - gradient parameters and
 - shading parameters

==== Motion links
To actually animate a fractal flame we must connect properties to motions.
Any motion can be connected with to number of fractal properties from any flame of the project.
[.thumb]
image::dancing_flames_motion_links.jpg[scaledwidth=50%]

==== Motion hierarchies
In certain cases it may make sense to group motions together. For example, to have a more "rough" motion (like a
motion curve which describes a basic rotation) where a "small" motion (like "beat") is added to.
To achieve this, you may choose a parent for any motion.
[.thumb]
image::dancing_flames_motion_hierarchy.jpg[scaledwidth=50%]

A motion having a parent can not explicitly be linked to a flame property (because it is already linked
implicitly over its parent).

=== Basic workflow
In the following sub-section a basic workflow is outlined.

==== Creating a flame-pool
The flame-pool is a collection of flames which belong to a dancing-flames-project and can all be
animated into this project. Simple projects start with only one flame in the pool, but there is no limit
and even if you have many flames in the pool, not all have to be used in the actual resulting video.

There a several ways to add flames to the pool:
 - Generate a batch using a random generator
 - import the currently load flame from the main editor
 - add a flame from the clipboard
 - load a batch from hard-disc

==== Adding sound (mp3)
Sound isn't actually required to create a dancing flame project, but the most projects will benefit
from sound. Currently, there can only be one mp3-file for the whole project (If you want to use more
than one sound file, you have to merge them and load them as single file)
To add a sound file, just press the _Load sound_ button and choose a mp3 file.

Please note, that the loading may take a while as the sound is actually processed and analyzed in
background.

==== Adjusting the projects FPS (frames per second)
The FPS setting of the project is one of the most important parameters, is affects how smooth your
animation will be and how many frames (=single images) you will have to generate in order to create
the final animation.
The more smooth your animation is, the more data has to be generated (and the more
large will be the resulting movie).
In my personal experience a fps value of 25 (i.e., 25 images shown per 1 second of the animation)
is a very good compromise.

==== Previewing the show
To preview the current animation press the _Start Show_ button. This will display a preview
animation and play back the sound.

In many cases the preview will not be able to follow your FPS setting. This is no problem because the
speed of the realtime-preview is not the speed at which the final animation will be created. The final
animation is always created at the true fps setting, even at slow machines.

==== Adjusting the speed of the realtime-preview
You can improve the speed of the realtime-preview by decreasing its size.
You can do this in real-time by modifying the slider of _border size_.

==== Switching between flames during the show
You may switch between the flames of your flame pool during the show all the time.
This is currently the only interaction which is actually required to be done during the show.

This kind of interaction is absolutely intended, and shall give your animation a more "spontaneous" or
"looking-alive" behavior. Just swap flames when you "feel" it.
To switch between flames just select them from the list-box in the project area during the show.

====  Recording a show
To record a show just enable the _Record show_ checkbox and start the show. Now any user action
(currently only switching between flames) is recorded accordingly to your fps setting.

After finishing the show (by pressing the _Stop show_ button) you will be prompted for an output path.
Just choose a directory and specify a base-name for the flame files to be generated.

Now JWildfire recalculates the show again at accurate FPS setting and produces the flame-files which
have to be rendered later to create the movie. Depending on the length of your show and the FPS
setting this may take a while and produce lots of files.
Please note that this phase is very important to have no hard interrupts (in order to create a really
accurate timing), you should leave your computer alone with it, especially if you have a rather slow
system.

==== Rendering the flames
The project until now was free from any output resolution settings and only fractal flames
where generated. You can render them using any resolution and quality settings later.
The recommended way is to use the <<batch_renderer, Batch renderer>> to perform final rendering.

[#batch_renderer]
== _Batch renderer_ module
[.thumb]
image::batch_renderer.jpg[scaledwidth=75%]

The batch renderer is designed to render fractal flames in the background (for example overnight).
Therefore it is well suited to render frames for animations or images with large resolution,
which take a while to render.
Open the Batch renderer module by selecting _Fractal flames: Batch renderer_ from the _Windows_ menu.

A special behavior of the _Batch renderer_ is the place where it places the finished images:
*all images rendered by the _Batch renderer_ are placed in the same folder as the corresponding
flame-file*. This makes it possible that the _Batch renderer_ recognizes already rendered
images (they are then skipped by default). This makes it also easy to pause and resume rendering.

=== _Render jobs_ table
All flames are displayed in a huge table which has some editable columns:

 - *custom size*: here you can enter a custom resolution when it should differ from the main
resolution selected in this this window. The format is *<width>x<height>*, for example: *1920x1080*.
 - *custom quality*: here you can enter a custom quality when it should differ from the main
quality selected in this window. The format is a numerical value, for example: *500* for a decent
quality level.
 - *render animation*: when you enter here a "1", JWildfire creates a whole .mp4-animation instead
a single .png-image. You can cancel and continue this at the frame level of the animation.
So when cancelling the rendering of an mp4-animation, you can continue it later at the
frame you cancelled it.

=== _Add files_ button
Here you can add a single flame or any number of flame files at once to the _render jobs_ table.

=== _Move down_ button
Flames are processed in order they are displayed in the _render jobs_ table. By using this button
you can move the currently selected flame one position down.

=== _Move up_ button
By using this button you can move the currently selected flame one position up.

=== _Remove_ button
Remove the currently selected flame from the _render jobs_ table. This does not delete
the flame file.

=== _Remove All_ button
Removes all flames from the _render jobs_ table. This does not delete any flame file.

=== _Settings: Resolution profile_
Select the <<resolution_profiles, Resolution profile>> which should be used for
all entries of _render jobs_ table.
If you want to use a differing resolution for certain flames, you may override this
setting by editing the column *custom size* for the individual flames.

=== _Settings: Quality profile_
Select the <<quality_profiles, Quality profile>> which should be used for
all entries of _render jobs_ table.
If you want to use a differing quality setting for certain flames, you may override this
setting by editing the column *custom quality* for the individual flames.

=== _Overwrite images_ checkbox
Per default the _Batch renderer_ will not re-render already rendered images.
You can change this by activating this checkbox.

=== _GPU_ toggle button
This toggle is only enabled, when <<gpu_rendering, _GPU rendering_>> is configured at your system.
When you activate this button, all images are rendered using the _GPU renderer_.
But please beware, that this is currently very limited and does not work well for many fractal flames.
So, you should test it with a single flame before GPU-rendering a longer batch.

=== _Show image_ button
Loads and displays the corrsponding image of the currently selected flame, if already rendered.

=== _Render_ button
Starts the rendering batch.

[#quilt_renderer]
== _Quilt Renderer_ module
[.thumb]
image::quilt_renderer.jpg[scaledwidth=75%]

The _Quilt Renderer_ allows you to render flames in nearly unlimited size.
This works by splitting the whole image into tiles.
Open the Quilt renderer module by selecting _Fractal Flames: Quilt renderer_ from the _Windows_ menu.

You may freely specify how the tiles are generated, for example, splitting the image in 3x2 tiles or 8 vertical stripes.

Each of the rendered tiles is a valid image. So, even if JWildfire would finally fail to assemble the tiles into one
final image (due to memory restrictions), you could perform this step using external image-processing-software,
which is more optimized to handle large images.
Images with a size upto 32K (30720x17280) were tested without any problems so far.

You can cancel/resume the rendering-process at tile-level.

Please note: Due to the nature of the fractal-flame-algorithm, the rendering of each tile may take as long as you
would render the whole image at once. So, this method is not efficient, but effective.
A 16K render on a modern computer can take about 12 hours, but you will usually get an awesome
result with endless details.

[#mesh_generator]
== _Mesh generator_ module
[.thumb]
image::mesh_generator.jpg[scaledwidth=75%]
Using the _mesh generator_ you can turn your fractals into _polygonal meshes_ or _point clouds_.
Open the Mesh generator module by selecting _Fractal flames: Mesh generator_ from the _Windows_ menu.

=== Generating _Polygonal meshes_ by slicing the fractal in _Voxel stacks_
The creation of solid meshes will not work well on any type of fractal and will
require some patience and experience to get nice results.
But once you have generated a nice mesh object, you may use it in any 3d-software
or even try to 3d-print it.

In JWildfire the process of generating _Polygonal meshes_ requires two steps:

- creating a number of slices through the fractal. (Those slices are called _Voxel stacks_
because they have both a fixed a resolution (like pixels in a image) and a certain depth.
So each slice contains of pixels with a depth, called a _Voxel_. And those slices stacked
together build a representation of the object, hence the name _Voxel stack_.)
- building a _polygonal mesh_ from all this slices using the popular _Marching Cubes Algorithm_.

==== _Total number of slices_
Sets the number of slices to be rendered which represents the voxel-resolution in z-direction.

==== _Render width_
Sets the render-resolution in x-direction which represents the voxel-resolution in x-direction.

==== _Render height_
Sets the render-resolution in y-direction which represents the voxel-resolution in y-direction.

==== _Slices per pass_
With this setting you can improve the speed of the scanning process in a significant way at the
cost of consumed memory.
When you have enough memory you can even set this to the _Total number of slices_
to create all slices at once.

*Please note, that those three values should match the shape of the desired object.*
So if you have a very thin, but very tall object, you may want a much higher resolution into z-direction.

==== _Generate_ (_Voxel stack_)
When the _Output type_ is set to *Voxelstack*, this will generate a batch of grayscale images
which represent the slices through the fractal (similar to the scans made by a computer tomography).

==== _Mesh generation_
Once you have finished to create a _Voxel stack_ you may create the final mesh at the _Mesh generation_ tab.

===== _From renderer_
Loads the previously rendered _Voxel stack_ without the need to select it in a file dialog.

===== _Load sequence_
Loads a previously rendered _Voxel stack_ from hard disc.

===== _Image downsample_
Downsample the slices by this factor to reduce noise. Reduces resolution, but increases quality of the mesh.

===== _Spatial filter radius_
Filter-radius used for downsampling

===== _Brighness threshold_
Brightness level at which the object is actually seen. Increasing this value may
also help to reduce background noise, but can also lead to loss of details.

===== _Image step_
With values higher than 1 you can skip slices.

===== _Post smoothing_
When you enable this checkbox you can apply a post-smoothing effect to the generated mesh.
This is an experimental feature and is only useful on a certain types of meshes.

===== _Generate_ (_Polygonal mesh_)
Using this button you generate the final _polygonal mesh_ from the currently loaded _Voxel stack_.

=== Generating _Point clouds_
Generating _Point clouds_ it a little bit more complex internally, but much more simple from the
users point of view. You have basically only to set up two parameters (_Cell size_ and _Render quality_)
and then the _Point cloud_ can be generated in one step.

==== Cell size
This is the most important parameter for generating _Point clouds_. It affects both memory consumption
and resolution of the final result. It represents the minimum absolute voxel size which can be filled
with information.
The smaller the _cell size_, the more voxels are generated and the more processing time is required.
Voxels are generated at two levels:

 - *raw voxels*: represent a result of a fractal iteration. Are generated at a scale of billions.
 - *final voxels*: represent a kind of _average_ of all _raw voxel_ in a cell of _cell size_

The smaller the _cell size_, the more calculations to create _final voxels_ are involved, and the
more memory is required to temporarily hold _raw voxels_.

*Please note, that the influence of this parameter is cubic.*
For example, halving it causes an increase of effort of factor 2 in 3 dimensions,
reaching a total factor of 2 * 2 * 2 = 8. As a comparison: it is like increasing
screen resolution, but into three directions instead of two.

==== _Generate_ (_Point cloud_)
When the _Output type_ is set to *Point cloud*, this will generate a _Point cloud_ in *.ply*-format.
You may process/view such files for example in _Houdini_ or _Meshlab_.

=== General options

==== _Output type_
There are two options:

 - *Voxel stack*: create a _Voxel step_ as first part of generating a _polygonal mesh_
 - *Pointcloud*: create a _point cloud_ in one step

==== _From Editor_
Transfers the currently edited fractal flame from the _Main Editor_ to the _Mesh generator_.

==== _From Clipboard_
Loads a fractal flame from the _Clipboard_ into the _Mesh generator_.

==== _Load Flame_
Loads a fractal flame from an external file into the _Mesh generator_.

==== _Fractal position_
This area contains controls to set the position and size of the fractal flame for
the scanning process. Any portions which are outside of the preview will not
be scanned and therefore will not be part of the generated mesh.

===== _CentreX_
Moves the fractal into x-direction.

===== _CentreY_
Moves the fractal into y-direction.

===== _Zoom_
Scales the fractal.

==== _Slice cutting range_
Here you set the start- and end-position of the scanning process in the z-direction.
Any portions of the fractal which are outside of this range will not
be scanned and therefore will not be part of the generated mesh.

===== _Position 1_
Sets the start position in z-direction for the scanning/slicing process.

===== _Position 2_
Sets the end position in z-direction for the scanning/slicing process.

Hint: the order of _Position 1_ and _Position 2_ does not matter, you may have _Position 1_ at
the top or at the botton, depending on how you prefer it.

==== _Render quality_
This sets the render quality for scanning the fractal.
Optimum values highly depend on the type of fractal.
Solid fractals usually need a high number of samples to be really clean.
Values in the range of 300 ... 2000 are typical.

[#gpu_rendering]
== _GPU render_ module
[.thumb]
image::gpu_render.jpg[scaledwidth=75%]

GPU rendering in JWildfire is enabled by integrating FAEngine, an GPU-rendering-engine,
created by Steven Brodhead.

=== Limitations
Currently, the engine is limited in terms of features (for example, supported variations) and
supported frameworks, but it actually works. And, it works very well.

For now, it only supports the Windows-platform, uses OpenCl and has a very limited
set of features (in comparison to the full JWildfire application, for example, 3D-rendering
is completely missed).

=== Requirements
You will need a modern graphics card with plenty of memory to make out the most of this
stuff.

=== Installation
The FAEngine comes as a separate package, you must download separately. This enables us to
update it more often than the main JWildfire application, if required.

The overall installation is simple:

 . Download the recent FACLRender-package from http://www.andreas-maschke.com/
 . Extract the download *.zip-file to some permanent path on you hard-disk, preferably
not on the Desktop, e. g. on D:\Program Files\FACLRender.
If you look into this folder, you should see a file FACLRender.exe
 . Start JWildfire and open the <<preferences, _Preferences_>>-window. Locate the property named
tinaFACLRenderPath and enter the path to folder which contains the FACLRender.exe.
In this example, enter "D:\Program Files\FACLRender"
  . Press the "Save and Close"-button and exit JWildfire
 . Start JWildfire again, now you should see a new entry "Fractal flames: GPU render"
in the main Window-menu (see section 3.).

==== Self-Test
To test the GPU-rendering itself (and to simplify further troubleshooting), please invoke
the self-test. Just enter the directory where you installed FACLRender and open the sub-folder
"selftest" ( In this example "D:\Program Files\FACLRender\selftest" ).
Double-click at the selftest.bat. If everything works as expected, you should see that
"selftest.png" was created. Otherwise, the console output hopefully helps to solve the
problem.

=== Rendering flames using the GPU
Use the "GPU renderer"-window to play with flames. This window works similar to the
Interactive renderer, you may import flames from the editor or load them from harddisc etc.

Most flames will not work flawless, as most flames have at least one feature which is not
supported by GPU-rendering at this time. But, of course, you will be able to create endless
beautiful flames, though.

=== Using the "Linear Only"-random-flame-generator
A good starting point is to use the "Linear Only"-random-flame-generator to create a batch
of flames which are guaranteed to work. Pick some nice one, transfer it to the GPU-render
and see how it performs. Add some feature, see if it is still supported by GPU, etc.

=== Batch rendering
When FACLRender is properly integrated into JWildfire there appears a new "GPU"-button
in the Batch-renderer. You may use it to render whole batches by using the GPU.
But, before you render a huge sequence, you should be sure that the flames do not use
features which are not supported by FACLRender. You may quickly do so by transferring
one of the flames to the "GPU renderer"-window and see if it works.

=== Troubleshooting
If rendering fails, you should check if the FACLRender.exe can detect any devices (or is
missing some vital library, for example). To do so, open a console/terminal window
and enter the directory where the FACLRender.exe resides.
Enter the command:
FACLRender
If the program can be started at all, it should output a list of options, one of then
being "-list"

So, enter the command:
FACLRender -list
to get a list of detected devices. When something is wrong, you hopefully will get some
useful information displayed here.

==== Visual C++ Redistributable for Visual Studio 2015
If some *.dlls are missing, installing the the
  "Visual C++ Redistributable for Visual Studio 2015"-Kit
from Microsoft will help in the most cases.

==== OpenCl drivers
Also, be sure to have OpenCl-drivers for your graphics card installed.

[#iflames_module]
== _IFlames_ module
[.thumb]
image::iflames.jpg[scaledwidth=75%]

This is an experimental application which combines particle simulation and fractal flames.

It requires a rather powerful computer, especially when you want to animate the iflames.

There are about 350-parameters to change, many of them may be animated:

- *Edge-finding*: controls where to place base-shapes
- *Global structure*: controls the global structure of the resulting iflame
- *Blending*: controls coloring
- *Dynamics*: controls global settings affecting dynamics aspects, like gravity
- *Base Flame Appearance*: controls the base-shapes inside an iflame (you may have up to 6 different base-shapes)
- *Size and orientation*: The size and orientation of the base-shapes
- *Distribution*: how to place which base-shape
- *Blending*: local coloring
- *Mutations*: controls how to create mutations from the base-shapes
- *Dynamics*: dynamic properties (like speed in a certain direction) of base-shapes

[#preferences]
== _Preferences_ window
[.thumb]
image::preferences.jpg[scaledwidth=75%]

In the _Preferences_-window you may customize JWildfire to your needs.
Open it by choosing _Preferences_ from the _Settings_ menu.

The customizable properties are key-value pairs which are displayed in one large table.
You may edit a property by double-clicking at the value in the 2nd column of the table.

Each property has a small description which is displayed at the bottom of the window.

[.thumb]
image::preferences_property_description.jpg[scaledwidth=75%]

Depending on the type of parameters, there are special parameter-editors available.
You reach them by double-clicking at the value in the 2nd column of the table, for example:
 - for color-parameters a color-selection-dialog is available
 - for folder-parameters (for example, to select the gradient-folder) you can both enter
the folder manually or select the folder using a folder-dialog

[.thumb]
image::preferences_choose_path.jpg[scaledwidth=75%]


Some properties may be changed "on the fly", others will need a restart of JWildfire in order
to show an effect. This is usually mentioned in the description of the property.

[#platform_specific_topics]
== Platform-specific topics (Windows, Mac, Steam, ...)
In this section some platform-specific topics are covered. Even if JWildfire is widely
platform-independent, there are features which are not avaiable on certain platforms.
Another topic are options for customizing the startup of the application which must
be specified in different ways, depending on the platform.

[#jvm_startup_parameters]
=== Startup options
In some cases it is necessary to set up some startup parameters for the application.
Such common cases are:

 - increase the <<max_mem, maximum amount of usable memory>> (to be able to render in higher resolutions)
 - increase the overall <<ui_scale, UI-scale>> (which may be too small on 4K monitors))
 - fix some <<ui_glitches, UI-glitches>>

The location of those parameters differs depending on the plattform.

==== Steam Edition
Currently, you must edit those parameters after each update.
To simplify this, there is a shortcut inside JWildfire to open the right file.
It is located under _Settings -> Startup settings (Steam)_.

When you click at this menu-item, it should open the file *<SteamApps>\common\JWildfire\app\JWildfire.cfg*
(When this does not work due to missing permissions, you may also open and edit this file manually).

Please see the sub-section <<jvm_settings_example, _Example (for both _Steam_ and _Mac_ version)_>> for an example.

==== App Store Edition
Currently, you must edit those parameters after each update.
Those parameters are inside a file named JWildfire.cfg inside the application folder.

To edit this file you must open the _Finder_ and locate application _JWildfire_ inside the _programs_ folder.
Right-click on the entry _JWildfire_ and select the option *Show Contents*. This will show the files
which belong to the application. Navigate to the sub-folder _Contents/app_ and you should see the file
_JWildfire.cfg_ inside this folder. You must edit this file in order to change the startup-parameters.

Please see the next sub-section <<jvm_settings_example, _Example (for both _Steam_ and _Mac_ version)_>>
for an example.

[#jvm_settings_example]
===== Example (for both _Steam_ and _Mac_ version)
Once you are editing the file _JWildfire.cfg_ it works the same for both the _Steam_ and the _Mac_ platform.

The file contains different sections, the _startup JVM parameters_ for JWildfire must be placed
under the section *[JavaOptions]*.

Example file:

[source]
----
[Application]
app.name=JWildfire
app.version=6.40
app.runtime=$ROOTDIR\runtime
app.identifier=org.jwildfire.swing
app.classpath=$ROOTDIR\app\j-wildfire.jar
app.mainjar=$ROOTDIR\app\j-wildfire.jar
app.mainclass=org.jwildfire.swing.JWildfire

[JavaOptions]
-splash:app/splash.png
-Xmx8G

[ArgOptions]
----
Here you see that under *[JavaOptions]* there is an entry *-Xmx8G*. This specifies the maximum
usable memory. The default is *8G*, which means 8 GB.
If you want to increase this to 32 GB, you just would change the line to:
[source]
----
...
[JavaOptions]
-splash:app/splash.png
-Xmx32G
...
----

=== Restrictions
==== Steam Edition (Windows only)
There are no restrictions. The Windows-based version of JWildfire currently has the most rich feature-set.

==== App Store Edition (Mac only)
On the Mac platform there are the following restrictions:

- the JWildfire-specific file-dialogs can not be used due to security-related requirements,
instead the macOS-native dialogs are used. This is not bad, because it gives you the typical
behavior on macOS, but there will be some missing features
- <<ai_based_denoiser, AI-based denoisers>> are not supported
- <<gpu_rendering, GPU rendering>> is not supported
- LeapMotion-controller-support is not available

==== Linux Version
There is no special Linux version, but the free version from the official website https://jwildfire.overwhale.com
does also work on Linux. To make it work, you must install a Java Virtual machine.

Then there are the following restrictions:

- <<ai_based_denoiser, AI-based denoisers>> are not supported
- <<gpu_rendering, GPU rendering>> is not supported
- LeapMotion-controller-support is not tested, probably does not work

== FAQ (frequently asked questions)
Here are answers to some popular questions which I get very often. They seem not fit well into
the other chapters, so I collected them in this section.

[#max_mem]
=== JWildfire does not use all my memory to render images at large resolutions
Due to its nature, JWildfire uses a fixed setting for the maximum memory it can use.
The default setting for this value is 8 GB.
When this limit is too low for you to render images at your desired resolution,
you can increase this value. To achieve this, you have to modify the JVM parameter *Xmx*.

For example, to increase the value to 32 GB, you should the *Xmx*-value in the _JWildfire.cfg_ like this:

[source]
----
--Xmx32G
----

You can also decrease the value, if you want to use less memory.

*Please note, that JWildfire will not start when this value exceeds the actual available memory
when you attempt to start the application.*

It is not recommended to use high values when you actually do not use them, because
too high values my degrade performance (slightly).

Please see the sub-section <<jvm_startup_parameters, Changing JVM startup parameters>> to see
how this file can be edited.

[#ui_scale]
=== The UI scale is microscopic (after an update)
Currently, the UI-scale must be set after each update.
You can increase the UI scale by changing the startup parameter *sun.java2d.uiScale*, for example:

[source]
----
-Dsun.java2d.uiScale=1.65
----

Please see the sub-section <<jvm_startup_parameters, Changing JVM startup parameters>> to see
how this can be achieved.

[#rendering_in_4k]
=== Are 4k renders possible?
Yes, you can.

You can literally render in any resolution, also 8k:

- by rendering a single image at once. The maximum render size is only restricted by your available memory.
(For really huge images, you may need patience, too.)
- by using the <<quilt_renderer, _Quilt-renderer_>>-module you may render really huge images in smaller parts, which are finally
assembled together. The maximum render size is also limited by memory. But often, you will
get other problems before reaching the memory-limit in JWildfire. For example, those image files can be very big (I have tested with
sizes up to 1 GB), and is hard to find other software which may process such large images.

=== Can I render images with removed/transparent background?
Yes, you can.

See the properties _Background transparency_ and _Fg opacity_ at the _Coloring_-tab.

You can also preview the rendering with transparent background. Set the _Display/hide transparency_ - button
at the preview-area.

=== How to save a flame as image?
You can not directly save a flame as an image. You must _render_ a flame in order
to generate an image. There are multiple options you can specify for rendering (for example: the output resolution),
so you can get out different images out of one fractal flame.

=== Is it possible to render flames at higher resolutions than inside JWildfire?
There are no restrictions regarding render size which could resolved by an external
application for rendering. The only limitation is memory.
See <<rendering_in_4k, Are 4k renders possible?>> for more information.

[#ui_glitches]
=== How to fix glitches/weird behavior of the UI
Some users have reported weird behavior of the UI:

- for example, one window overwriting the content of another
- or windows following the mouse pointer

It seems that this is causes by some misconfiguration of
_DirectDraw_-acceleration of Java2D (maybe some driver issue).

The known solution is to switch to _OpenGL_-acceleration or turn _DirectDraw_ off.

==== Option 1: Enable _OpenGL_
set the following _JVM parameter_:
[source,java]
----
-Dsun.java2d.opengl=True
----

(the uppercase T is correct)

==== Option 2 (if option 1 does not work): Disable _DirectDraw_
set the following _JVM parameter_:
[source,java]
----
-Dsun.java2d.noddraw=true
----
(the lowercase t is correct)

*Please note, that only one of those _JVM parameters_ should be set at the same time.*

The location of those _JVM Parameters_ is platform-specific.
Please see the section <<platform_specific_topics, _Platform-specific topics_>> for more informations
about changing _JVM Parameters_.
